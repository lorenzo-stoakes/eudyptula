From: Lorenzo Stoakes <lstoakes@gmail.com>
Date: Sat, 10 Jan 2015 19:50:00 +0000
Subject: [PATCH RESEND 1/4] staging: rtl8192u: fix comments

This patch fixes errors raised by checkpatch.pl relating to use of C99 comments
in r8192U_dm.c, and cleans up existing ANSI C comments.

Signed-off-by: Lorenzo Stoakes <lstoakes@gmail.com>
---
 drivers/staging/rtl8192u/r8192U_dm.c | 811 ++++++++++++++++++-----------------
 1 file changed, 420 insertions(+), 391 deletions(-)

diff --git a/drivers/staging/rtl8192u/r8192U_dm.c b/drivers/staging/rtl8192u/r8192U_dm.c
index 936565d..cafc717 100644
--- a/drivers/staging/rtl8192u/r8192U_dm.c
+++ b/drivers/staging/rtl8192u/r8192U_dm.c
@@ -21,9 +21,7 @@ Major Change History:
 #include "r8190_rtl8256.h"
 #include "r819xU_cmdpkt.h"
 /*---------------------------Define Local Constant---------------------------*/
-//
-// Indicate different AP vendor for IOT issue.
-//
+/* Indicate different AP vendor for IOT issue. */
 static u32 edca_setting_DL[HT_IOT_PEER_MAX] =
 		{ 0x5e4322,	0x5e4322,	0x5e4322,	0x604322,	0xa44f,		0x5ea44f};
 static u32 edca_setting_UL[HT_IOT_PEER_MAX] =
@@ -36,11 +34,11 @@ static u32 edca_setting_UL[HT_IOT_PEER_MAX] =


 /*------------------------Define global variable-----------------------------*/
-// Debug variable ?
+/* Debug variable ? */
 dig_t	dm_digtable;
-// Store current software write register content for MAC PHY.
+/* Store current software write register content for MAC PHY. */
 u8		dm_shadow[16][256] = {{0}};
-// For Dynamic Rx Path Selection by Signal Strength
+/* For Dynamic Rx Path Selection by Signal Strength */
 DRxPathSel	DM_RxPathSelTable;
 /*------------------------Define global variable-----------------------------*/

@@ -56,24 +54,24 @@ extern	void dm_check_fsync(struct net_device *dev);


 /*---------------------Define local function prototype-----------------------*/
-// DM --> Rate Adaptive
+/* DM --> Rate Adaptive */
 static	void	dm_check_rate_adaptive(struct net_device *dev);

-// DM --> Bandwidth switch
+/* DM --> Bandwidth switch */
 static	void	dm_init_bandwidth_autoswitch(struct net_device *dev);
 static	void	dm_bandwidth_autoswitch(struct net_device *dev);

-// DM --> TX power control
-//static	void	dm_initialize_txpower_tracking(struct net_device *dev);
+/* DM --> TX power control */
+/*static	void	dm_initialize_txpower_tracking(struct net_device *dev);*/

 static	void	dm_check_txpower_tracking(struct net_device *dev);



-//static	void	dm_txpower_reset_recovery(struct net_device *dev);
+/*static	void	dm_txpower_reset_recovery(struct net_device *dev);*/


-// DM --> Dynamic Init Gain by RSSI
+/* DM --> Dynamic Init Gain by RSSI */
 static	void	dm_dig_init(struct net_device *dev);
 static	void	dm_ctrl_initgain_byrssi(struct net_device *dev);
 static	void	dm_ctrl_initgain_byrssi_highpwr(struct net_device *dev);
@@ -84,61 +82,61 @@ static	void	dm_pd_th(struct net_device *dev);
 static	void	dm_cs_ratio(struct net_device *dev);

 static	void dm_init_ctstoself(struct net_device *dev);
-// DM --> EDCA turbo mode control
+/* DM --> EDCA turbo mode control */
 static	void	dm_check_edca_turbo(struct net_device *dev);

-//static	void	dm_gpio_change_rf(struct net_device *dev);
-// DM --> Check PBC
+/*static	void	dm_gpio_change_rf(struct net_device *dev);*/
+/* DM --> Check PBC */
 static	void dm_check_pbc_gpio(struct net_device *dev);


-// DM --> Check current RX RF path state
+/* DM --> Check current RX RF path state */
 static	void	dm_check_rx_path_selection(struct net_device *dev);
 static	void dm_init_rxpath_selection(struct net_device *dev);
 static	void dm_rxpath_sel_byrssi(struct net_device *dev);


-// DM --> Fsync for broadcom ap
+/* DM --> Fsync for broadcom ap */
 static void dm_init_fsync(struct net_device *dev);
 static void dm_deInit_fsync(struct net_device *dev);

-//Added by vivi, 20080522
+/* Added by vivi, 20080522 */
 static	void	dm_check_txrateandretrycount(struct net_device *dev);

 /*---------------------Define local function prototype-----------------------*/

-/*---------------------Define of Tx Power Control For Near/Far Range --------*/   //Add by Jacken 2008/02/18
+/*---------------------Define of Tx Power Control For Near/Far Range --------*/   /*Add by Jacken 2008/02/18 */
 static	void	dm_init_dynamic_txpower(struct net_device *dev);
 static	void	dm_dynamic_txpower(struct net_device *dev);


-// DM --> For rate adaptive and DIG, we must send RSSI to firmware
+/* DM --> For rate adaptive and DIG, we must send RSSI to firmware */
 static	void dm_send_rssi_tofw(struct net_device *dev);
 static	void	dm_ctstoself(struct net_device *dev);
 /*---------------------------Define function prototype------------------------*/
-//================================================================================
-//	HW Dynamic mechanism interface.
-//================================================================================
-
-//
-//	Description:
-//		Prepare SW resource for HW dynamic mechanism.
-//
-//	Assumption:
-//		This function is only invoked at driver intialization once.
-//
-//
+/*
+ * ================================================================================
+ *	HW Dynamic mechanism interface.
+ * ================================================================================
+ *
+ *
+ *	Description:
+ *		Prepare SW resource for HW dynamic mechanism.
+ *
+ *	Assumption:
+ *		This function is only invoked at driver intialization once.
+ */
 void init_hal_dm(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);

-	// Undecorated Smoothed Signal Strength, it can utilized to dynamic mechanism.
+	/* Undecorated Smoothed Signal Strength, it can utilized to dynamic mechanism. */
 	priv->undecorated_smoothed_pwdb = -1;

-	//Initial TX Power Control for near/far range , add by amy 2008/05/15, porting from windows code.
+	/* Initial TX Power Control for near/far range , add by amy 2008/05/15, porting from windows code. */
 	dm_init_dynamic_txpower(dev);
 	init_rate_adaptive(dev);
-	//dm_initialize_txpower_tracking(dev);
+	/*dm_initialize_txpower_tracking(dev);*/
 	dm_dig_init(dev);
 	dm_init_edca_turbo(dev);
 	dm_init_bandwidth_autoswitch(dev);
@@ -146,7 +144,7 @@ void init_hal_dm(struct net_device *dev)
 	dm_init_rxpath_selection(dev);
 	dm_init_ctstoself(dev);

-}	// InitHalDm
+}	/* InitHalDm */

 void deinit_hal_dm(struct net_device *dev)
 {
@@ -208,16 +206,16 @@ void dm_CheckRxAggregation(struct net_device *dev) {

 	lastTxOkCnt = priv->stats.txbytesunicast;
 	lastRxOkCnt = priv->stats.rxbytesunicast;
-}	// dm_CheckEdcaTurbo
+}	/* dm_CheckEdcaTurbo */
 #endif



 void hal_dm_watchdog(struct net_device *dev)
 {
-	//struct r8192_priv *priv = ieee80211_priv(dev);
+	/*struct r8192_priv *priv = ieee80211_priv(dev);*/

-	//static u8	previous_bssid[6] ={0};
+	/*static u8	previous_bssid[6] ={0};*/

 	/*Add by amy 2008/05/15 ,porting from windows code.*/
 	dm_check_rate_adaptive(dev);
@@ -230,22 +228,22 @@ void hal_dm_watchdog(struct net_device *dev)
 	dm_check_rx_path_selection(dev);
 	dm_check_fsync(dev);

-	// Add by amy 2008-05-15 porting from windows code.
+	/* Add by amy 2008-05-15 porting from windows code. */
 	dm_check_pbc_gpio(dev);
 	dm_send_rssi_tofw(dev);
 	dm_ctstoself(dev);
 #ifdef USB_RX_AGGREGATION_SUPPORT
 	dm_CheckRxAggregation(dev);
 #endif
-}	//HalDmWatchDog
+}	/* HalDmWatchDog */


 /*
-  * Decide Rate Adaptive Set according to distance (signal strength)
-  *	01/11/2008	MHC		Modify input arguments and RATR table level.
-  *	01/16/2008	MHC		RF_Type is assigned in ReadAdapterInfo(). We must call
-  *						the function after making sure RF_Type.
-  */
+ * Decide Rate Adaptive Set according to distance (signal strength)
+ *	01/11/2008	MHC		Modify input arguments and RATR table level.
+ *	01/16/2008	MHC		RF_Type is assigned in ReadAdapterInfo(). We must call
+ *						the function after making sure RF_Type.
+ */
 void init_rate_adaptive(struct net_device *dev)
 {

@@ -270,14 +268,16 @@ void init_rate_adaptive(struct net_device *dev)

 	if (priv->rf_type == RF_2T4R)
 	{
-		// 07/10/08 MH Modify for RA smooth scheme.
-		/* 2008/01/11 MH Modify 2T RATR table for different RSSI. 080515 porting by amy from windows code.*/
+		/*
+		 * 07/10/08 MH Modify for RA smooth scheme.
+		 * 2008/01/11 MH Modify 2T RATR table for different RSSI. 080515 porting by amy from windows code.
+		 */
 		pra->upper_rssi_threshold_ratr		=	0x8f0f0000;
 		pra->middle_rssi_threshold_ratr		=	0x8f0ff000;
 		pra->low_rssi_threshold_ratr		=	0x8f0ff001;
 		pra->low_rssi_threshold_ratr_40M	=	0x8f0ff005;
 		pra->low_rssi_threshold_ratr_20M	=	0x8f0ff001;
-		pra->ping_rssi_ratr	=	0x0000000d;//cosa add for test
+		pra->ping_rssi_ratr	=	0x0000000d;/* cosa add for test */
 	}
 	else if (priv->rf_type == RF_1T2R)
 	{
@@ -286,10 +286,10 @@ void init_rate_adaptive(struct net_device *dev)
 		pra->low_rssi_threshold_ratr		=	0x000ff001;
 		pra->low_rssi_threshold_ratr_40M	=	0x000ff005;
 		pra->low_rssi_threshold_ratr_20M	=	0x000ff001;
-		pra->ping_rssi_ratr	=	0x0000000d;//cosa add for test
+		pra->ping_rssi_ratr	=	0x0000000d;/* cosa add for test */
 	}

-}	// InitRateAdaptive
+}	/* InitRateAdaptive */


 /*-----------------------------------------------------------------------------
@@ -325,21 +325,21 @@ static void dm_check_rate_adaptive(struct net_device *dev)
 		return;
 	}

-	if(pra->rate_adaptive_disabled)//this variable is set by ioctl.
+	if(pra->rate_adaptive_disabled) /* this variable is set by ioctl. */
 		return;

-	// TODO: Only 11n mode is implemented currently,
+	/* TODO: Only 11n mode is implemented currently, */
 	if(!(priv->ieee80211->mode == WIRELESS_MODE_N_24G ||
 		 priv->ieee80211->mode == WIRELESS_MODE_N_5G))
 		 return;

 	if(priv->ieee80211->state == IEEE80211_LINKED)
 	{
-	//	RT_TRACE(COMP_RATE, "dm_CheckRateAdaptive(): \t");
+		/*RT_TRACE(COMP_RATE, "dm_CheckRateAdaptive(): \t");*/

-		//
-		// Check whether Short GI is enabled
-		//
+		/*
+		 * Check whether Short GI is enabled
+		 */
 		bshort_gi_enabled = (pHTInfo->bCurTxBW40MHz && pHTInfo->bCurShortGI40MHz) ||
 			(!pHTInfo->bCurTxBW40MHz && pHTInfo->bCurShortGI20MHz);

@@ -360,7 +360,7 @@ static void dm_check_rate_adaptive(struct net_device *dev)
 			pra->low_rssi_threshold_ratr =
 			(pra->low_rssi_threshold_ratr_20M & (~BIT31)) | ((bshort_gi_enabled)? BIT31:0) ;
 		}
-		//cosa add for test
+		/* cosa add for test */
 		pra->ping_rssi_ratr =
 				(pra->ping_rssi_ratr & (~BIT31)) | ((bshort_gi_enabled)? BIT31:0) ;

@@ -387,56 +387,58 @@ static void dm_check_rate_adaptive(struct net_device *dev)
 					(pra->low_rssi_thresh_for_ra40M):(pra->low_rssi_thresh_for_ra20M);
 		}

-		//DbgPrint("[DM] THresh H/L=%d/%d\n\r", RATR.HighRSSIThreshForRA, RATR.LowRSSIThreshForRA);
+		/*DbgPrint("[DM] THresh H/L=%d/%d\n\r", RATR.HighRSSIThreshForRA, RATR.LowRSSIThreshForRA);*/
 		if(priv->undecorated_smoothed_pwdb >= (long)HighRSSIThreshForRA)
 		{
-			//DbgPrint("[DM] RSSI=%d STA=HIGH\n\r", pHalData->UndecoratedSmoothedPWDB);
+			/*DbgPrint("[DM] RSSI=%d STA=HIGH\n\r", pHalData->UndecoratedSmoothedPWDB);*/
 			pra->ratr_state = DM_RATR_STA_HIGH;
 			targetRATR = pra->upper_rssi_threshold_ratr;
 		}else if(priv->undecorated_smoothed_pwdb >= (long)LowRSSIThreshForRA)
 		{
-			//DbgPrint("[DM] RSSI=%d STA=Middle\n\r", pHalData->UndecoratedSmoothedPWDB);
+			/*DbgPrint("[DM] RSSI=%d STA=Middle\n\r", pHalData->UndecoratedSmoothedPWDB);*/
 			pra->ratr_state = DM_RATR_STA_MIDDLE;
 			targetRATR = pra->middle_rssi_threshold_ratr;
 		}else
 		{
-			//DbgPrint("[DM] RSSI=%d STA=LOW\n\r", pHalData->UndecoratedSmoothedPWDB);
+			/*DbgPrint("[DM] RSSI=%d STA=LOW\n\r", pHalData->UndecoratedSmoothedPWDB);*/
 			pra->ratr_state = DM_RATR_STA_LOW;
 			targetRATR = pra->low_rssi_threshold_ratr;
 		}

-			//cosa add for test
+		/* cosa add for test */
 		if(pra->ping_rssi_enable)
 		{
-			//pHalData->UndecoratedSmoothedPWDB = 19;
+			/*pHalData->UndecoratedSmoothedPWDB = 19;*/
 			if(priv->undecorated_smoothed_pwdb < (long)(pra->ping_rssi_thresh_for_ra+5))
 			{
 				if((priv->undecorated_smoothed_pwdb < (long)pra->ping_rssi_thresh_for_ra) ||
 					ping_rssi_state)
 				{
-					//DbgPrint("TestRSSI = %d, set RATR to 0x%x \n", pHalData->UndecoratedSmoothedPWDB, pRA->TestRSSIRATR);
+					/*DbgPrint("TestRSSI = %d, set RATR to 0x%x \n", pHalData->UndecoratedSmoothedPWDB, pRA->TestRSSIRATR);*/
 					pra->ratr_state = DM_RATR_STA_LOW;
 					targetRATR = pra->ping_rssi_ratr;
 					ping_rssi_state = 1;
 				}
-				//else
-				//	DbgPrint("TestRSSI is between the range. \n");
+				/*else
+					DbgPrint("TestRSSI is between the range. \n");*/
 			}
 			else
 			{
-				//DbgPrint("TestRSSI Recover to 0x%x \n", targetRATR);
+				/*DbgPrint("TestRSSI Recover to 0x%x \n", targetRATR);*/
 				ping_rssi_state = 0;
 			}
 		}

-		// 2008.04.01
-		// For RTL819X, if pairwisekey = wep/tkip, we support only MCS0~7.
+		/*
+		 * 2008.04.01
+		 * For RTL819X, if pairwisekey = wep/tkip, we support only MCS0~7.
+		 */
 		if(priv->ieee80211->GetHalfNmodeSupportByAPsHandler(dev))
 			targetRATR &=  0xf00fffff;

-		//
-		// Check whether updating of RATR0 is required
-		//
+		/*
+		 * Check whether updating of RATR0 is required
+		 */
 		read_nic_dword(dev, RATR0, &currentRATR);
 		if(targetRATR !=  currentRATR)
 		{
@@ -459,7 +461,7 @@ static void dm_check_rate_adaptive(struct net_device *dev)
 		pra->ratr_state = DM_RATR_STA_MAX;
 	}

-}	// dm_CheckRateAdaptive
+}	/* dm_CheckRateAdaptive */


 static void dm_init_bandwidth_autoswitch(struct net_device *dev)
@@ -471,7 +473,7 @@ static void dm_init_bandwidth_autoswitch(struct net_device *dev)
 	priv->ieee80211->bandwidth_auto_switch.bforced_tx20Mhz = false;
 	priv->ieee80211->bandwidth_auto_switch.bautoswitch_enable = false;

-}	// dm_init_bandwidth_autoswitch
+}	/* dm_init_bandwidth_autoswitch */


 static void dm_bandwidth_autoswitch(struct net_device *dev)
@@ -481,68 +483,68 @@ static void dm_bandwidth_autoswitch(struct net_device *dev)
 	if(priv->CurrentChannelBW == HT_CHANNEL_WIDTH_20 ||!priv->ieee80211->bandwidth_auto_switch.bautoswitch_enable){
 		return;
 	}else{
-		if(priv->ieee80211->bandwidth_auto_switch.bforced_tx20Mhz == false){//If send packets in 40 Mhz in 20/40
+		if(priv->ieee80211->bandwidth_auto_switch.bforced_tx20Mhz == false){ /* If send packets in 40 Mhz in 20/40 */
 			if(priv->undecorated_smoothed_pwdb <= priv->ieee80211->bandwidth_auto_switch.threshold_40Mhzto20Mhz)
 				priv->ieee80211->bandwidth_auto_switch.bforced_tx20Mhz = true;
-		}else{//in force send packets in 20 Mhz in 20/40
+		}else{ /* in force send packets in 20 Mhz in 20/40 */
 			if(priv->undecorated_smoothed_pwdb >= priv->ieee80211->bandwidth_auto_switch.threshold_20Mhzto40Mhz)
 				priv->ieee80211->bandwidth_auto_switch.bforced_tx20Mhz = false;

 		}
 	}
-}	// dm_BandwidthAutoSwitch
+}	/* dm_BandwidthAutoSwitch */

-//OFDM default at 0db, index=6.
+/* OFDM default at 0db, index=6. */
 static u32 OFDMSwingTable[OFDM_Table_Length] = {
-	0x7f8001fe,	// 0, +6db
-	0x71c001c7,	// 1, +5db
-	0x65400195,	// 2, +4db
-	0x5a400169,	// 3, +3db
-	0x50800142,	// 4, +2db
-	0x47c0011f,	// 5, +1db
-	0x40000100,	// 6, +0db ===> default, upper for higher temperature, lower for low temperature
-	0x390000e4,	// 7, -1db
-	0x32c000cb,	// 8, -2db
-	0x2d4000b5,	// 9, -3db
-	0x288000a2,	// 10, -4db
-	0x24000090,	// 11, -5db
-	0x20000080,	// 12, -6db
-	0x1c800072,	// 13, -7db
-	0x19800066,	// 14, -8db
-	0x26c0005b,	// 15, -9db
-	0x24400051,	// 16, -10db
-	0x12000048,	// 17, -11db
-	0x10000040	// 18, -12db
+	0x7f8001fe,	/* 0, +6db */
+	0x71c001c7,	/* 1, +5db */
+	0x65400195,	/* 2, +4db */
+	0x5a400169,	/* 3, +3db */
+	0x50800142,	/* 4, +2db */
+	0x47c0011f,	/* 5, +1db */
+	0x40000100,	/* 6, +0db ===> default, upper for higher temperature, lower for low temperature */
+	0x390000e4,	/* 7, -1db */
+	0x32c000cb,	/* 8, -2db */
+	0x2d4000b5,	/* 9, -3db */
+	0x288000a2,	/* 10, -4db */
+	0x24000090,	/* 11, -5db */
+	0x20000080,	/* 12, -6db */
+	0x1c800072,	/* 13, -7db */
+	0x19800066,	/* 14, -8db */
+	0x26c0005b,	/* 15, -9db */
+	0x24400051,	/* 16, -10db */
+	0x12000048,	/* 17, -11db */
+	0x10000040	/* 18, -12db */
 };

 static u8	CCKSwingTable_Ch1_Ch13[CCK_Table_length][8] = {
-	{0x36, 0x35, 0x2e, 0x25, 0x1c, 0x12, 0x09, 0x04},	// 0, +0db ===> CCK40M default
-	{0x30, 0x2f, 0x29, 0x21, 0x19, 0x10, 0x08, 0x03},	// 1, -1db
-	{0x2b, 0x2a, 0x25, 0x1e, 0x16, 0x0e, 0x07, 0x03},	// 2, -2db
-	{0x26, 0x25, 0x21, 0x1b, 0x14, 0x0d, 0x06, 0x03},	// 3, -3db
-	{0x22, 0x21, 0x1d, 0x18, 0x11, 0x0b, 0x06, 0x02},	// 4, -4db
-	{0x1f, 0x1e, 0x1a, 0x15, 0x10, 0x0a, 0x05, 0x02},	// 5, -5db
-	{0x1b, 0x1a, 0x17, 0x13, 0x0e, 0x09, 0x04, 0x02},	// 6, -6db ===> CCK20M default
-	{0x18, 0x17, 0x15, 0x11, 0x0c, 0x08, 0x04, 0x02},	// 7, -7db
-	{0x16, 0x15, 0x12, 0x0f, 0x0b, 0x07, 0x04, 0x01},	// 8, -8db
-	{0x13, 0x13, 0x10, 0x0d, 0x0a, 0x06, 0x03, 0x01},	// 9, -9db
-	{0x11, 0x11, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},	// 10, -10db
-	{0x0f, 0x0f, 0x0d, 0x0b, 0x08, 0x05, 0x03, 0x01}	// 11, -11db
+	{0x36, 0x35, 0x2e, 0x25, 0x1c, 0x12, 0x09, 0x04},	/* 0, +0db ===> CCK40M default */
+	{0x30, 0x2f, 0x29, 0x21, 0x19, 0x10, 0x08, 0x03},	/* 1, -1db */
+	{0x2b, 0x2a, 0x25, 0x1e, 0x16, 0x0e, 0x07, 0x03},	/* 2, -2db */
+	{0x26, 0x25, 0x21, 0x1b, 0x14, 0x0d, 0x06, 0x03},	/* 3, -3db */
+	{0x22, 0x21, 0x1d, 0x18, 0x11, 0x0b, 0x06, 0x02},	/* 4, -4db */
+	{0x1f, 0x1e, 0x1a, 0x15, 0x10, 0x0a, 0x05, 0x02},	/* 5, -5db */
+	{0x1b, 0x1a, 0x17, 0x13, 0x0e, 0x09, 0x04, 0x02},	/* 6, -6db ===> CCK20M default */
+	{0x18, 0x17, 0x15, 0x11, 0x0c, 0x08, 0x04, 0x02},	/* 7, -7db */
+	{0x16, 0x15, 0x12, 0x0f, 0x0b, 0x07, 0x04, 0x01},	/* 8, -8db */
+	{0x13, 0x13, 0x10, 0x0d, 0x0a, 0x06, 0x03, 0x01},	/* 9, -9db */
+	{0x11, 0x11, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},	/* 10, -10db */
+	{0x0f, 0x0f, 0x0d, 0x0b, 0x08, 0x05, 0x03, 0x01}	/* 11, -11db */
 };

 static u8	CCKSwingTable_Ch14[CCK_Table_length][8] = {
-	{0x36, 0x35, 0x2e, 0x1b, 0x00, 0x00, 0x00, 0x00},	// 0, +0db  ===> CCK40M default
-	{0x30, 0x2f, 0x29, 0x18, 0x00, 0x00, 0x00, 0x00},	// 1, -1db
-	{0x2b, 0x2a, 0x25, 0x15, 0x00, 0x00, 0x00, 0x00},	// 2, -2db
-	{0x26, 0x25, 0x21, 0x13, 0x00, 0x00, 0x00, 0x00},	// 3, -3db
-	{0x22, 0x21, 0x1d, 0x11, 0x00, 0x00, 0x00, 0x00},	// 4, -4db
-	{0x1f, 0x1e, 0x1a, 0x0f, 0x00, 0x00, 0x00, 0x00},	// 5, -5db
-	{0x1b, 0x1a, 0x17, 0x0e, 0x00, 0x00, 0x00, 0x00},	// 6, -6db  ===> CCK20M default
-	{0x18, 0x17, 0x15, 0x0c, 0x00, 0x00, 0x00, 0x00},	// 7, -7db
-	{0x16, 0x15, 0x12, 0x0b, 0x00, 0x00, 0x00, 0x00},	// 8, -8db
-	{0x13, 0x13, 0x10, 0x0a, 0x00, 0x00, 0x00, 0x00},	// 9, -9db
-	{0x11, 0x11, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},	// 10, -10db
-	{0x0f, 0x0f, 0x0d, 0x08, 0x00, 0x00, 0x00, 0x00}	// 11, -11db
+	{0x36, 0x35, 0x2e, 0x1b, 0x00, 0x00, 0x00, 0x00},	/* 0, +0db  ===> CCK40M default */
+	{0x30, 0x2f, 0x29, 0x18, 0x00, 0x00, 0x00, 0x00},	/* 1, -1db */
+	{0x2b, 0x2a, 0x25, 0x15, 0x00, 0x00, 0x00, 0x00},	/* 2, -2db */
+	{0x26, 0x25, 0x21, 0x13, 0x00, 0x00, 0x00, 0x00},	/* 3, -3db */
+	{0x22, 0x21, 0x1d, 0x11, 0x00, 0x00, 0x00, 0x00},	/* 4, -4db */
+	{0x1f, 0x1e, 0x1a, 0x0f, 0x00, 0x00, 0x00, 0x00},	/* 5, -5db */
+	{0x1b, 0x1a, 0x17, 0x0e, 0x00, 0x00, 0x00, 0x00},	/* 6, -6db  ===> CCK20M default */
+	{0x18, 0x17, 0x15, 0x0c, 0x00, 0x00, 0x00, 0x00},	/* 7, -7db */
+	{0x16, 0x15, 0x12, 0x0b, 0x00, 0x00, 0x00, 0x00},	/* 8, -8db */
+	{0x13, 0x13, 0x10, 0x0a, 0x00, 0x00, 0x00, 0x00},	/* 9, -9db */
+	{0x11, 0x11, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},	/* 10, -10db */
+	{0x0f, 0x0f, 0x0d, 0x08, 0x00, 0x00, 0x00, 0x00}	/* 11, -11db */
 };

 static void dm_TXPowerTrackingCallback_TSSI(struct net_device *dev)
@@ -556,7 +558,7 @@ static void dm_TXPowerTrackingCallback_TSSI(struct net_device *dev)
 	u32						Value;
 	u8						Pwr_Flag;
 	u16						Avg_TSSI_Meas, TSSI_13dBm, Avg_TSSI_Meas_from_driver=0;
-	//RT_STATUS				rtStatus = RT_STATUS_SUCCESS;
+	/*RT_STATUS				rtStatus = RT_STATUS_SUCCESS;*/
 	bool rtStatus = true;
 	u32						delta=0;

@@ -572,8 +574,7 @@ static void dm_TXPowerTrackingCallback_TSSI(struct net_device *dev)
 	RT_TRACE(COMP_POWER_TRACKING, "powerlevelOFDM24G = %x\n", powerlevelOFDM24G);

 	for(j = 0; j<=30; j++)
-{	//fill tx_cmd
-
+{	/* fill tx_cmd */
 	tx_cmd.Op		= TXCMD_SET_TX_PWR_TRACKING;
 	tx_cmd.Length	= 4;
 	tx_cmd.Value		= Value;
@@ -583,7 +584,7 @@ static void dm_TXPowerTrackingCallback_TSSI(struct net_device *dev)
 		RT_TRACE(COMP_POWER_TRACKING, "Set configuration with tx cmd queue fail!\n");
 	}
 	mdelay(1);
-	//DbgPrint("hi, vivi, strange\n");
+	/*DbgPrint("hi, vivi, strange\n");*/
 	for(i = 0;i <= 30; i++)
 	{
 		read_nic_byte(dev, 0x1ba, &Pwr_Flag);
@@ -609,7 +610,7 @@ static void dm_TXPowerTrackingCallback_TSSI(struct net_device *dev)
 			RT_TRACE(COMP_POWER_TRACKING, "TSSI_report_value = %d\n", tmp_report[k]);
 		}

-		//check if the report value is right
+		/* check if the report value is right */
 		for(k = 0;k < 5; k++)
 		{
 			if(tmp_report[k] <= 20)
@@ -638,8 +639,8 @@ static void dm_TXPowerTrackingCallback_TSSI(struct net_device *dev)
 		TSSI_13dBm = priv->TSSI_13dBm;
 		RT_TRACE(COMP_POWER_TRACKING, "TSSI_13dBm = %d\n", TSSI_13dBm);

-		//if(abs(Avg_TSSI_Meas_from_driver - TSSI_13dBm) <= E_FOR_TX_POWER_TRACK)
-		// For MacOS-compatible
+		/*if(abs(Avg_TSSI_Meas_from_driver - TSSI_13dBm) <= E_FOR_TX_POWER_TRACK)*/
+		/* For MacOS-compatible */
 		if(Avg_TSSI_Meas_from_driver > TSSI_13dBm)
 			delta = Avg_TSSI_Meas_from_driver - TSSI_13dBm;
 		else
@@ -741,9 +742,9 @@ static void dm_TXPowerTrackingCallback_ThermalMeter(struct net_device *dev)

 	if(!priv->btxpower_trackingInit)
 	{
-		//Query OFDM default setting
+		/* Query OFDM default setting */
 		tmpRegA= rtl8192_QueryBBReg(dev, rOFDM0_XATxIQImbalance, bMaskDWord);
-		for(i=0; i<OFDM_Table_Length; i++)	//find the index
+		for(i=0; i<OFDM_Table_Length; i++)	/* find the index */
 		{
 			if(tmpRegA == OFDMSwingTable[i])
 			{
@@ -753,7 +754,7 @@ static void dm_TXPowerTrackingCallback_ThermalMeter(struct net_device *dev)
 			}
 		}

-		//Query CCK default setting From 0xa22
+		/* Query CCK default setting From 0xa22 */
 		TempCCk = rtl8192_QueryBBReg(dev, rCCK0_TxFilter1, bMaskByte2);
 		for(i=0 ; i<CCK_Table_length ; i++)
 		{
@@ -766,27 +767,29 @@ static void dm_TXPowerTrackingCallback_ThermalMeter(struct net_device *dev)
 			}
 		}
 		priv->btxpower_trackingInit = TRUE;
-		//pHalData->TXPowercount = 0;
+		/*pHalData->TXPowercount = 0;*/
 		return;
 	}

-	//==========================
-	// this is only for test, should be masked
-	//==========================
+	/*
+	 * ==========================
+	 * this is only for test, should be masked
+	 * ==========================
+	 */

-	// read and filter out unreasonable value
-	tmpRegA = rtl8192_phy_QueryRFReg(dev, RF90_PATH_A, 0x12, 0x078);	// 0x12: RF Reg[10:7]
+	/* read and filter out unreasonable value */
+	tmpRegA = rtl8192_phy_QueryRFReg(dev, RF90_PATH_A, 0x12, 0x078);	/* 0x12: RF Reg[10:7] */
 	RT_TRACE(COMP_POWER_TRACKING, "Readback ThermalMeterA = %d \n", tmpRegA);
 	if(tmpRegA < 3 || tmpRegA > 13)
 		return;
-	if(tmpRegA >= 12)	// if over 12, TP will be bad when high temperature
+	if(tmpRegA >= 12)	/* if over 12, TP will be bad when high temperature */
 		tmpRegA = 12;
 	RT_TRACE(COMP_POWER_TRACKING, "Valid ThermalMeterA = %d \n", tmpRegA);
-	priv->ThermalMeter[0] = ThermalMeterVal;	//We use fixed value by Bryant's suggestion
-	priv->ThermalMeter[1] = ThermalMeterVal;	//We use fixed value by Bryant's suggestion
+	priv->ThermalMeter[0] = ThermalMeterVal;	/* We use fixed value by Bryant's suggestion */
+	priv->ThermalMeter[1] = ThermalMeterVal;	/* We use fixed value by Bryant's suggestion */

-	//Get current RF-A temperature index
-	if(priv->ThermalMeter[0] >= (u8)tmpRegA)	//lower temperature
+	/* Get current RF-A temperature index */
+	if(priv->ThermalMeter[0] >= (u8)tmpRegA)	/* lower temperature */
 	{
 		tmpOFDMindex = tmpCCK20Mindex = 6+(priv->ThermalMeter[0]-(u8)tmpRegA);
 		tmpCCK40Mindex = tmpCCK20Mindex - 6;
@@ -800,16 +803,16 @@ static void dm_TXPowerTrackingCallback_ThermalMeter(struct net_device *dev)
 	else
 	{
 		tmpval = ((u8)tmpRegA - priv->ThermalMeter[0]);
-		if(tmpval >= 6)								// higher temperature
-			tmpOFDMindex = tmpCCK20Mindex = 0;		// max to +6dB
+		if(tmpval >= 6)					/* higher temperature */
+			tmpOFDMindex = tmpCCK20Mindex = 0;	/* max to +6dB */
 		else
 			tmpOFDMindex = tmpCCK20Mindex = 6 - tmpval;
 		tmpCCK40Mindex = 0;
 	}
-	//DbgPrint("%ddb, tmpOFDMindex = %d, tmpCCK20Mindex = %d, tmpCCK40Mindex = %d",
-		//((u1Byte)tmpRegA - pHalData->ThermalMeter[0]),
-		//tmpOFDMindex, tmpCCK20Mindex, tmpCCK40Mindex);
-	if(priv->CurrentChannelBW != HT_CHANNEL_WIDTH_20)	//40M
+	/*DbgPrint("%ddb, tmpOFDMindex = %d, tmpCCK20Mindex = %d, tmpCCK40Mindex = %d",
+		((u1Byte)tmpRegA - pHalData->ThermalMeter[0]),
+		tmpOFDMindex, tmpCCK20Mindex, tmpCCK40Mindex);*/
+	if(priv->CurrentChannelBW != HT_CHANNEL_WIDTH_20)	/* 40M */
 		tmpCCKindex = tmpCCK40Mindex;
 	else
 		tmpCCKindex = tmpCCK20Mindex;
@@ -833,7 +836,7 @@ static void dm_TXPowerTrackingCallback_ThermalMeter(struct net_device *dev)

 	if(CCKSwingNeedUpdate)
 	{
-		//DbgPrint("Update CCK Swing, CCK_index = %d\n", pHalData->CCK_index);
+		/*DbgPrint("Update CCK Swing, CCK_index = %d\n", pHalData->CCK_index);*/
 		dm_cck_txpower_adjust(dev, priv->bcck_in_ch14);
 	}
 	if(priv->OFDM_index != tmpOFDMindex)
@@ -864,7 +867,7 @@ static void dm_InitializeTXPowerTracking_TSSI(struct net_device *dev)

 	struct r8192_priv *priv = ieee80211_priv(dev);

-	//Initial the Tx BB index and mapping value
+	/* Initial the Tx BB index and mapping value */
 	priv->txbbgain_table[0].txbb_iq_amplifygain =			12;
 	priv->txbbgain_table[0].txbbgain_value=0x7f8001fe;
 	priv->txbbgain_table[1].txbb_iq_amplifygain =			11;
@@ -940,8 +943,10 @@ static void dm_InitializeTXPowerTracking_TSSI(struct net_device *dev)
 	priv->txbbgain_table[36].txbb_iq_amplifygain =		     -24;
 	priv->txbbgain_table[36].txbbgain_value=0x10000040;

-	//ccktxbb_valuearray[0] is 0xA22 [1] is 0xA24 ...[7] is 0xA29
-	//This Table is for CH1~CH13
+	/*
+	 * ccktxbb_valuearray[0] is 0xA22 [1] is 0xA24 ...[7] is 0xA29
+	 * This Table is for CH1~CH13
+	 */
 	priv->cck_txbbgain_table[0].ccktxbb_valuearray[0] = 0x36;
 	priv->cck_txbbgain_table[0].ccktxbb_valuearray[1] = 0x35;
 	priv->cck_txbbgain_table[0].ccktxbb_valuearray[2] = 0x2e;
@@ -1149,8 +1154,10 @@ static void dm_InitializeTXPowerTracking_TSSI(struct net_device *dev)
 	priv->cck_txbbgain_table[22].ccktxbb_valuearray[6] = 0x03;
 	priv->cck_txbbgain_table[22].ccktxbb_valuearray[7] = 0x01;

-	//ccktxbb_valuearray[0] is 0xA22 [1] is 0xA24 ...[7] is 0xA29
-	//This Table is for CH14
+	/*
+	 * ccktxbb_valuearray[0] is 0xA22 [1] is 0xA24 ...[7] is 0xA29
+	 * This Table is for CH14
+	 */
 	priv->cck_txbbgain_ch14_table[0].ccktxbb_valuearray[0] = 0x36;
 	priv->cck_txbbgain_ch14_table[0].ccktxbb_valuearray[1] = 0x35;
 	priv->cck_txbbgain_ch14_table[0].ccktxbb_valuearray[2] = 0x2e;
@@ -1368,9 +1375,11 @@ static void dm_InitializeTXPowerTracking_ThermalMeter(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);

-	// Tx Power tracking by Thermal Meter requires Firmware R/W 3-wire. This mechanism
-	// can be enabled only when Firmware R/W 3-wire is enabled. Otherwise, frequent r/w
-	// 3-wire by driver causes RF to go into a wrong state.
+	/*
+	 * Tx Power tracking by Thermal Meter requires Firmware R/W 3-wire. This mechanism
+	 * can be enabled only when Firmware R/W 3-wire is enabled. Otherwise, frequent r/w
+	 * 3-wire by driver causes RF to go into a wrong state.
+	 */
 	if(priv->ieee80211->FwRWRF)
 		priv->btxpower_tracking = TRUE;
 	else
@@ -1387,7 +1396,7 @@ void dm_initialize_txpower_tracking(struct net_device *dev)
 		dm_InitializeTXPowerTracking_TSSI(dev);
 	else
 		dm_InitializeTXPowerTracking_ThermalMeter(dev);
-}// dm_InitializeTXPowerTracking
+} /* dm_InitializeTXPowerTracking */


 static void dm_CheckTXPowerTracking_TSSI(struct net_device *dev)
@@ -1413,7 +1422,7 @@ static void dm_CheckTXPowerTracking_ThermalMeter(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	static u8	TM_Trigger;
-	//DbgPrint("dm_CheckTXPowerTracking() \n");
+	/*DbgPrint("dm_CheckTXPowerTracking() \n");*/
 	if(!priv->btxpower_tracking)
 		return;
 	else
@@ -1427,9 +1436,11 @@ static void dm_CheckTXPowerTracking_ThermalMeter(struct net_device *dev)

 	if(!TM_Trigger)
 	{
-		//Attention!! You have to write all 12bits of data to RF, or it may cause RF to crash
-		//actually write reg0x02 bit1=0, then bit1=1.
-		//DbgPrint("Trigger ThermalMeter, write RF reg0x2 = 0x4d to 0x4f\n");
+		/*
+		 * Attention!! You have to write all 12bits of data to RF, or it may cause RF to crash
+		 * actually write reg0x02 bit1=0, then bit1=1.
+		 * DbgPrint("Trigger ThermalMeter, write RF reg0x2 = 0x4d to 0x4f\n");
+		 */
 		rtl8192_phy_SetRFReg(dev, RF90_PATH_A, 0x02, bMask12Bits, 0x4d);
 		rtl8192_phy_SetRFReg(dev, RF90_PATH_A, 0x02, bMask12Bits, 0x4f);
 		rtl8192_phy_SetRFReg(dev, RF90_PATH_A, 0x02, bMask12Bits, 0x4d);
@@ -1439,7 +1450,7 @@ static void dm_CheckTXPowerTracking_ThermalMeter(struct net_device *dev)
 	}
 	else
 	{
-		//DbgPrint("Schedule TxPowerTrackingWorkItem\n");
+		/*DbgPrint("Schedule TxPowerTrackingWorkItem\n");*/
 			queue_delayed_work(priv->priv_wq,&priv->txpower_tracking_wq,0);
 		TM_Trigger = 0;
 	}
@@ -1449,7 +1460,7 @@ static void dm_CheckTXPowerTracking_ThermalMeter(struct net_device *dev)
 static void dm_check_txpower_tracking(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
-	//static u32 tx_power_track_counter = 0;
+	/*static u32 tx_power_track_counter = 0;*/

 #ifdef  RTL8190P
 	dm_CheckTXPowerTracking_TSSI(dev);
@@ -1460,28 +1471,28 @@ static void dm_check_txpower_tracking(struct net_device *dev)
 		dm_CheckTXPowerTracking_ThermalMeter(dev);
 #endif

-}	// dm_CheckTXPowerTracking
+}	/* dm_CheckTXPowerTracking */


 static void dm_CCKTxPowerAdjust_TSSI(struct net_device *dev, bool  bInCH14)
 {
 	u32 TempVal;
 	struct r8192_priv *priv = ieee80211_priv(dev);
-	//Write 0xa22 0xa23
+	/* Write 0xa22 0xa23 */
 	TempVal = 0;
 	if(!bInCH14){
-		//Write 0xa22 0xa23
+		/* Write 0xa22 0xa23 */
 		TempVal =	priv->cck_txbbgain_table[priv->cck_present_attentuation].ccktxbb_valuearray[0] +
 					(priv->cck_txbbgain_table[priv->cck_present_attentuation].ccktxbb_valuearray[1]<<8) ;

 		rtl8192_setBBreg(dev, rCCK0_TxFilter1, bMaskHWord, TempVal);
-		//Write 0xa24 ~ 0xa27
+		/* Write 0xa24 ~ 0xa27 */
 		TempVal =	priv->cck_txbbgain_table[priv->cck_present_attentuation].ccktxbb_valuearray[2] +
 					(priv->cck_txbbgain_table[priv->cck_present_attentuation].ccktxbb_valuearray[3]<<8) +
 					(priv->cck_txbbgain_table[priv->cck_present_attentuation].ccktxbb_valuearray[4]<<16)+
 					(priv->cck_txbbgain_table[priv->cck_present_attentuation].ccktxbb_valuearray[5]<<24);
 		rtl8192_setBBreg(dev, rCCK0_TxFilter2, bMaskDWord, TempVal);
-		//Write 0xa28  0xa29
+		/* Write 0xa28  0xa29 */
 		TempVal =	priv->cck_txbbgain_table[priv->cck_present_attentuation].ccktxbb_valuearray[6] +
 					(priv->cck_txbbgain_table[priv->cck_present_attentuation].ccktxbb_valuearray[7]<<8) ;

@@ -1493,13 +1504,13 @@ static void dm_CCKTxPowerAdjust_TSSI(struct net_device *dev, bool  bInCH14)
 					(priv->cck_txbbgain_ch14_table[priv->cck_present_attentuation].ccktxbb_valuearray[1]<<8) ;

 		rtl8192_setBBreg(dev, rCCK0_TxFilter1, bMaskHWord, TempVal);
-		//Write 0xa24 ~ 0xa27
+		/* Write 0xa24 ~ 0xa27 */
 		TempVal =	priv->cck_txbbgain_ch14_table[priv->cck_present_attentuation].ccktxbb_valuearray[2] +
 					(priv->cck_txbbgain_ch14_table[priv->cck_present_attentuation].ccktxbb_valuearray[3]<<8) +
 					(priv->cck_txbbgain_ch14_table[priv->cck_present_attentuation].ccktxbb_valuearray[4]<<16)+
 					(priv->cck_txbbgain_ch14_table[priv->cck_present_attentuation].ccktxbb_valuearray[5]<<24);
 		rtl8192_setBBreg(dev, rCCK0_TxFilter2, bMaskDWord, TempVal);
-		//Write 0xa28  0xa29
+		/* Write 0xa28  0xa29 */
 		TempVal =	priv->cck_txbbgain_ch14_table[priv->cck_present_attentuation].ccktxbb_valuearray[6] +
 					(priv->cck_txbbgain_ch14_table[priv->cck_present_attentuation].ccktxbb_valuearray[7]<<8) ;

@@ -1517,13 +1528,13 @@ static void dm_CCKTxPowerAdjust_ThermalMeter(struct net_device *dev,	bool  bInCH
 	TempVal = 0;
 	if(!bInCH14)
 	{
-		//Write 0xa22 0xa23
+		/* Write 0xa22 0xa23 */
 		TempVal =	CCKSwingTable_Ch1_Ch13[priv->CCK_index][0] +
 					(CCKSwingTable_Ch1_Ch13[priv->CCK_index][1]<<8) ;
 		rtl8192_setBBreg(dev, rCCK0_TxFilter1, bMaskHWord, TempVal);
 		RT_TRACE(COMP_POWER_TRACKING, "CCK not chnl 14, reg 0x%x = 0x%x\n",
 			rCCK0_TxFilter1, TempVal);
-		//Write 0xa24 ~ 0xa27
+		/* Write 0xa24 ~ 0xa27 */
 		TempVal =	CCKSwingTable_Ch1_Ch13[priv->CCK_index][2] +
 					(CCKSwingTable_Ch1_Ch13[priv->CCK_index][3]<<8) +
 					(CCKSwingTable_Ch1_Ch13[priv->CCK_index][4]<<16)+
@@ -1531,7 +1542,7 @@ static void dm_CCKTxPowerAdjust_ThermalMeter(struct net_device *dev,	bool  bInCH
 		rtl8192_setBBreg(dev, rCCK0_TxFilter2, bMaskDWord, TempVal);
 		RT_TRACE(COMP_POWER_TRACKING, "CCK not chnl 14, reg 0x%x = 0x%x\n",
 			rCCK0_TxFilter2, TempVal);
-		//Write 0xa28  0xa29
+		/* Write 0xa28  0xa29 */
 		TempVal =	CCKSwingTable_Ch1_Ch13[priv->CCK_index][6] +
 					(CCKSwingTable_Ch1_Ch13[priv->CCK_index][7]<<8) ;

@@ -1541,15 +1552,15 @@ static void dm_CCKTxPowerAdjust_ThermalMeter(struct net_device *dev,	bool  bInCH
 	}
 	else
 	{
-//		priv->CCKTxPowerAdjustCntNotCh14++;	//cosa add for debug.
-		//Write 0xa22 0xa23
+		/*priv->CCKTxPowerAdjustCntNotCh14++;	cosa add for debug.*/
+		/* Write 0xa22 0xa23 */
 		TempVal =	CCKSwingTable_Ch14[priv->CCK_index][0] +
 					(CCKSwingTable_Ch14[priv->CCK_index][1]<<8) ;

 		rtl8192_setBBreg(dev, rCCK0_TxFilter1, bMaskHWord, TempVal);
 		RT_TRACE(COMP_POWER_TRACKING, "CCK chnl 14, reg 0x%x = 0x%x\n",
 			rCCK0_TxFilter1, TempVal);
-		//Write 0xa24 ~ 0xa27
+		/* Write 0xa24 ~ 0xa27 */
 		TempVal =	CCKSwingTable_Ch14[priv->CCK_index][2] +
 					(CCKSwingTable_Ch14[priv->CCK_index][3]<<8) +
 					(CCKSwingTable_Ch14[priv->CCK_index][4]<<16)+
@@ -1557,7 +1568,7 @@ static void dm_CCKTxPowerAdjust_ThermalMeter(struct net_device *dev,	bool  bInCH
 		rtl8192_setBBreg(dev, rCCK0_TxFilter2, bMaskDWord, TempVal);
 		RT_TRACE(COMP_POWER_TRACKING, "CCK chnl 14, reg 0x%x = 0x%x\n",
 			rCCK0_TxFilter2, TempVal);
-		//Write 0xa28  0xa29
+		/* Write 0xa28  0xa29 */
 		TempVal =	CCKSwingTable_Ch14[priv->CCK_index][6] +
 					(CCKSwingTable_Ch14[priv->CCK_index][7]<<8) ;

@@ -1570,7 +1581,7 @@ static void dm_CCKTxPowerAdjust_ThermalMeter(struct net_device *dev,	bool  bInCH


 void dm_cck_txpower_adjust(struct net_device *dev, bool binch14)
-{	// dm_CCKTxPowerAdjust
+{	/*  dm_CCKTxPowerAdjust */

 	struct r8192_priv *priv = ieee80211_priv(dev);
 	if(priv->bDcut == TRUE)
@@ -1600,7 +1611,7 @@ static void dm_txpower_reset_recovery(
 	RT_TRACE(COMP_POWER_TRACKING, "Reset Recovery: Fill in RFC_txPowerTrackingIndex is %x\n",priv->rfc_txpowertrackingindex);
 	RT_TRACE(COMP_POWER_TRACKING, "Reset Recovery : RF C I/Q Amplify Gain is %ld\n",priv->txbbgain_table[priv->rfc_txpowertrackingindex].txbb_iq_amplifygain);

-}	// dm_TXPowerResetRecovery
+}	/* dm_TXPowerResetRecovery */

 void dm_restore_dynamic_mechanism_state(struct net_device *dev)
 {
@@ -1613,12 +1624,10 @@ void dm_restore_dynamic_mechanism_state(struct net_device *dev)
 		return;
 	}

-	//
-	// Restore previous state for rate adaptive
-	//
+	/* Restore previous state for rate adaptive */
 	if(priv->rate_adaptive.rate_adaptive_disabled)
 		return;
-	// TODO: Only 11n mode is implemented currently,
+	/* TODO: Only 11n mode is implemented currently, */
 	if(!(priv->ieee80211->mode==WIRELESS_MODE_N_24G ||
 		 priv->ieee80211->mode==WIRELESS_MODE_N_5G))
 		 return;
@@ -1626,38 +1635,36 @@ void dm_restore_dynamic_mechanism_state(struct net_device *dev)
 			/* 2007/11/15 MH Copy from 8190PCI. */
 			u32 ratr_value;
 			ratr_value = reg_ratr;
-			if(priv->rf_type == RF_1T2R)	// 1T2R, Spatial Stream 2 should be disabled
+			if(priv->rf_type == RF_1T2R)	/* 1T2R, Spatial Stream 2 should be disabled */
 			{
 				ratr_value &= ~(RATE_ALL_OFDM_2SS);
-				//DbgPrint("HW_VAR_TATR_0 from 0x%x ==> 0x%x\n", ((pu4Byte)(val))[0], ratr_value);
+				/*DbgPrint("HW_VAR_TATR_0 from 0x%x ==> 0x%x\n", ((pu4Byte)(val))[0], ratr_value);*/
 			}
-			//DbgPrint("set HW_VAR_TATR_0 = 0x%x\n", ratr_value);
-			//cosa PlatformEFIOWrite4Byte(Adapter, RATR0, ((pu4Byte)(val))[0]);
+			/*DbgPrint("set HW_VAR_TATR_0 = 0x%x\n", ratr_value);*/
+			/*cosa PlatformEFIOWrite4Byte(Adapter, RATR0, ((pu4Byte)(val))[0]);*/
 			write_nic_dword(dev, RATR0, ratr_value);
 			write_nic_byte(dev, UFWP, 1);
 	}
-	//Restore TX Power Tracking Index
+	/* Restore TX Power Tracking Index */
 	if (priv->btxpower_trackingInit && priv->btxpower_tracking)
 		dm_txpower_reset_recovery(dev);

-	//
-	//Restore BB Initial Gain
-	//
+	/* Restore BB Initial Gain */
 	dm_bb_initialgain_restore(dev);

-}	// DM_RestoreDynamicMechanismState
+}	/* DM_RestoreDynamicMechanismState */

 static void dm_bb_initialgain_restore(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
-	u32 bit_mask = 0x7f; //Bit0~ Bit6
+	u32 bit_mask = 0x7f; /* Bit0~ Bit6 */

 	if(dm_digtable.dig_algorithm == DIG_ALGO_BY_RSSI)
 		return;

-	//Disable Initial Gain
-	//PHY_SetBBReg(Adapter, UFWP, bMaskLWord, 0x800);
-	rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x8);	// Only clear byte 1 and rewrite.
+	/* Disable Initial Gain */
+	/*PHY_SetBBReg(Adapter, UFWP, bMaskLWord, 0x800);*/
+	rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x8);	/* Only clear byte 1 and rewrite. */
 	rtl8192_setBBreg(dev, rOFDM0_XAAGCCore1, bit_mask, (u32)priv->initgain_backup.xaagccore1);
 	rtl8192_setBBreg(dev, rOFDM0_XBAGCCore1, bit_mask, (u32)priv->initgain_backup.xbagccore1);
 	rtl8192_setBBreg(dev, rOFDM0_XCAGCCore1, bit_mask, (u32)priv->initgain_backup.xcagccore1);
@@ -1670,36 +1677,36 @@ static void dm_bb_initialgain_restore(struct net_device *dev)
 	RT_TRACE(COMP_DIG, "dm_BBInitialGainRestore 0xc60 is %x\n",priv->initgain_backup.xcagccore1);
 	RT_TRACE(COMP_DIG, "dm_BBInitialGainRestore 0xc68 is %x\n",priv->initgain_backup.xdagccore1);
 	RT_TRACE(COMP_DIG, "dm_BBInitialGainRestore 0xa0a is %x\n",priv->initgain_backup.cca);
-	//Enable Initial Gain
-	//PHY_SetBBReg(Adapter, UFWP, bMaskLWord, 0x100);
-	rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x1);	// Only clear byte 1 and rewrite.
+	/* Enable Initial Gain */
+	/*PHY_SetBBReg(Adapter, UFWP, bMaskLWord, 0x100);*/
+	rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x1);	/* Only clear byte 1 and rewrite. */

-}	// dm_BBInitialGainRestore
+}	/* dm_BBInitialGainRestore */


 void dm_backup_dynamic_mechanism_state(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);

-	// Fsync to avoid reset
+	/* Fsync to avoid reset */
 	priv->bswitch_fsync  = false;
 	priv->bfsync_processing = false;
-	//Backup BB InitialGain
+	/* Backup BB InitialGain */
 	dm_bb_initialgain_backup(dev);

-}	// DM_BackupDynamicMechanismState
+}	/* DM_BackupDynamicMechanismState */


 static void dm_bb_initialgain_backup(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
-	u32 bit_mask = bMaskByte0; //Bit0~ Bit6
+	u32 bit_mask = bMaskByte0; /* Bit0~ Bit6 */

 	if(dm_digtable.dig_algorithm == DIG_ALGO_BY_RSSI)
 		return;

-	//PHY_SetBBReg(Adapter, UFWP, bMaskLWord, 0x800);
-	rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x8);	// Only clear byte 1 and rewrite.
+	/*PHY_SetBBReg(Adapter, UFWP, bMaskLWord, 0x800);*/
+	rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x8);	/* Only clear byte 1 and rewrite. */
 	priv->initgain_backup.xaagccore1 = (u8)rtl8192_QueryBBReg(dev, rOFDM0_XAAGCCore1, bit_mask);
 	priv->initgain_backup.xbagccore1 = (u8)rtl8192_QueryBBReg(dev, rOFDM0_XBAGCCore1, bit_mask);
 	priv->initgain_backup.xcagccore1 = (u8)rtl8192_QueryBBReg(dev, rOFDM0_XCAGCCore1, bit_mask);
@@ -1713,7 +1720,7 @@ static void dm_bb_initialgain_backup(struct net_device *dev)
 	RT_TRACE(COMP_DIG, "BBInitialGainBackup 0xc68 is %x\n",priv->initgain_backup.xdagccore1);
 	RT_TRACE(COMP_DIG, "BBInitialGainBackup 0xa0a is %x\n",priv->initgain_backup.cca);

-}   // dm_BBInitialGainBakcup
+}   /* dm_BBInitialGainBakcup */

 #endif
 /*-----------------------------------------------------------------------------
@@ -1824,7 +1831,7 @@ static void dm_dig_init(struct net_device *dev)
 	/* 2007/10/05 MH Disable DIG scheme now. Not tested. */
 	dm_digtable.dig_enable_flag	= true;
 	dm_digtable.dig_algorithm = DIG_ALGO_BY_RSSI;
-	dm_digtable.dbg_mode = DM_DBG_OFF;	//off=by real rssi value, on=by DM_DigTable.Rssi_val for new dig
+	dm_digtable.dbg_mode = DM_DBG_OFF;	/* off=by real rssi value, on=by DM_DigTable.Rssi_val for new dig */
 	dm_digtable.dig_algorithm_switch = 0;

 	/* 2007/10/04 MH Define init gain threshold. */
@@ -1838,7 +1845,7 @@ static void dm_dig_init(struct net_device *dev)
 	dm_digtable.rssi_high_power_lowthresh = DM_DIG_HIGH_PWR_THRESH_LOW;
 	dm_digtable.rssi_high_power_highthresh = DM_DIG_HIGH_PWR_THRESH_HIGH;

-	dm_digtable.rssi_val = 50;	//for new dig debug rssi value
+	dm_digtable.rssi_val = 50;	/* for new dig debug rssi value */
 	dm_digtable.backoff_val = DM_DIG_BACKOFF;
 	dm_digtable.rx_gain_range_max = DM_DIG_MAX;
 	if(priv->CustomerID == RT_CID_819x_Netcore)
@@ -1876,7 +1883,7 @@ static void dm_ctrl_initgain_byrssi(struct net_device *dev)
 		dm_ctrl_initgain_byrssi_by_fwfalse_alarm(dev);
 	else if(dm_digtable.dig_algorithm == DIG_ALGO_BY_RSSI)
 		dm_ctrl_initgain_byrssi_by_driverrssi(dev);
-//		;
+	/* ; */
 	else
 		return;
 }
@@ -1892,15 +1899,16 @@ static void dm_ctrl_initgain_byrssi_by_driverrssi(
 	if (dm_digtable.dig_enable_flag == false)
 		return;

-	//DbgPrint("Dig by Sw Rssi \n");
-	if(dm_digtable.dig_algorithm_switch)	// if switched algorithm, we have to disable FW Dig.
+	/*DbgPrint("Dig by Sw Rssi \n");*/
+	if(dm_digtable.dig_algorithm_switch)	/* if switched algorithm, we have to disable FW Dig. */
 		fw_dig = 0;
-	if(fw_dig <= 3)	// execute several times to make sure the FW Dig is disabled
-	{// FW DIG Off
+	if(fw_dig <= 3)
+	{	/* execute several times to make sure the FW Dig is disabled */
+		/* FW DIG Off */
 		for(i=0; i<3; i++)
-			rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x8);	// Only clear byte 1 and rewrite.
+			rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x8);	/* Only clear byte 1 and rewrite. */
 		fw_dig++;
-		dm_digtable.dig_state = DM_STA_DIG_OFF;	//fw dig off.
+		dm_digtable.dig_state = DM_STA_DIG_OFF;	/* fw dig off. */
 	}

 	if(priv->ieee80211->state == IEEE80211_LINKED)
@@ -1908,12 +1916,12 @@ static void dm_ctrl_initgain_byrssi_by_driverrssi(
 	else
 		dm_digtable.cur_connect_state = DIG_DISCONNECT;

-	//DbgPrint("DM_DigTable.PreConnectState = %d, DM_DigTable.CurConnectState = %d \n",
-		//DM_DigTable.PreConnectState, DM_DigTable.CurConnectState);
+	/*DbgPrint("DM_DigTable.PreConnectState = %d, DM_DigTable.CurConnectState = %d \n",
+		DM_DigTable.PreConnectState, DM_DigTable.CurConnectState);*/

 	if(dm_digtable.dbg_mode == DM_DBG_OFF)
 		dm_digtable.rssi_val = priv->undecorated_smoothed_pwdb;
-	//DbgPrint("DM_DigTable.Rssi_val = %d \n", DM_DigTable.Rssi_val);
+	/*DbgPrint("DM_DigTable.Rssi_val = %d \n", DM_DigTable.Rssi_val);*/
 	dm_initial_gain(dev);
 	dm_pd_th(dev);
 	dm_cs_ratio(dev);
@@ -1936,23 +1944,23 @@ static void dm_ctrl_initgain_byrssi_by_fwfalse_alarm(
 	if(dm_digtable.dig_algorithm_switch)
 	{
 		dm_digtable.dig_state = DM_STA_DIG_MAX;
-		// Fw DIG On.
+		/* Fw DIG On. */
 		for(i=0; i<3; i++)
-			rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x1);	// Only clear byte 1 and rewrite.
+			rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x1);	/* Only clear byte 1 and rewrite.*/
 		dm_digtable.dig_algorithm_switch = 0;
 	}

 	if (priv->ieee80211->state != IEEE80211_LINKED)
 		return;

-	// For smooth, we can not change DIG state.
+	/* For smooth, we can not change DIG state. */
 	if ((priv->undecorated_smoothed_pwdb > dm_digtable.rssi_low_thresh) &&
 		(priv->undecorated_smoothed_pwdb < dm_digtable.rssi_high_thresh))
 	{
 		return;
 	}
-	//DbgPrint("Dig by Fw False Alarm\n");
-	//if (DM_DigTable.Dig_State == DM_STA_DIG_OFF)
+	/*DbgPrint("Dig by Fw False Alarm\n");*/
+	/*if (DM_DigTable.Dig_State == DM_STA_DIG_OFF)*/
 	/*DbgPrint("DIG Check\n\r RSSI=%d LOW=%d HIGH=%d STATE=%d",
 	pHalData->UndecoratedSmoothedPWDB, DM_DigTable.RssiLowThresh,
 	DM_DigTable.RssiHighThresh, DM_DigTable.Dig_State);*/
@@ -1972,42 +1980,42 @@ static void dm_ctrl_initgain_byrssi_by_fwfalse_alarm(
 			reset_cnt = priv->reset_count;
 		}

-		// If DIG is off, DIG high power state must reset.
+		/* If DIG is off, DIG high power state must reset. */
 		dm_digtable.dig_highpwr_state = DM_STA_DIG_MAX;
 		dm_digtable.dig_state = DM_STA_DIG_OFF;

-		// 1.1 DIG Off.
-		rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x8);	// Only clear byte 1 and rewrite.
+		/*  1.1 DIG Off. */
+		rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x8);	/*  Only clear byte 1 and rewrite. */

-		// 1.2 Set initial gain.
+		/*  1.2 Set initial gain. */
 		write_nic_byte(dev, rOFDM0_XAAGCCore1, 0x17);
 		write_nic_byte(dev, rOFDM0_XBAGCCore1, 0x17);
 		write_nic_byte(dev, rOFDM0_XCAGCCore1, 0x17);
 		write_nic_byte(dev, rOFDM0_XDAGCCore1, 0x17);

-		// 1.3 Lower PD_TH for OFDM.
+		/*  1.3 Lower PD_TH for OFDM. */
 		if (priv->CurrentChannelBW != HT_CHANNEL_WIDTH_20)
 		{
-			/* 2008/01/11 MH 40MHZ 90/92 register are not the same. */
-			// 2008/02/05 MH SD3-Jerry 92U/92E PD_TH are the same.
+			/*
+			 * 2008/01/11 MH 40MHZ 90/92 register are not the same.
+			 * 2008/02/05 MH SD3-Jerry 92U/92E PD_TH are the same.
+			 */
 			write_nic_byte(dev, (rOFDM0_XATxAFE+3), 0x00);
 			/*else if (priv->card_8192 == HARDWARE_TYPE_RTL8190P)
 				write_nic_byte(pAdapter, rOFDM0_RxDetector1, 0x40);
+			else if (pAdapter->HardwareType == HARDWARE_TYPE_RTL8192E)
+			else
+				PlatformEFIOWrite1Byte(pAdapter, rOFDM0_RxDetector1, 0x40);
 			*/
-			//else if (pAdapter->HardwareType == HARDWARE_TYPE_RTL8192E)
-
-
-			//else
-				//PlatformEFIOWrite1Byte(pAdapter, rOFDM0_RxDetector1, 0x40);
 		}
 		else
 			write_nic_byte(dev, rOFDM0_RxDetector1, 0x42);

-		// 1.4 Lower CS ratio for CCK.
+		/* 1.4 Lower CS ratio for CCK. */
 		write_nic_byte(dev, 0xa0a, 0x08);

-		// 1.5 Higher EDCCA.
-		//PlatformEFIOWrite4Byte(pAdapter, rOFDM0_ECCAThreshold, 0x325);
+		/* 1.5 Higher EDCCA. */
+		/*PlatformEFIOWrite4Byte(pAdapter, rOFDM0_ECCAThreshold, 0x325);*/
 		return;

 	}
@@ -2033,10 +2041,12 @@ static void dm_ctrl_initgain_byrssi_by_fwfalse_alarm(
 		}

 		dm_digtable.dig_state = DM_STA_DIG_ON;
-		//DbgPrint("DIG ON\n\r");
+		/*DbgPrint("DIG ON\n\r");*/

-		// 2.1 Set initial gain.
-		// 2008/02/26 MH SD3-Jerry suggest to prevent dirty environment.
+		/*
+		 * 2.1 Set initial gain.
+		 * 2008/02/26 MH SD3-Jerry suggest to prevent dirty environment.
+		 */
 		if (reset_flag == 1)
 		{
 			write_nic_byte(dev, rOFDM0_XAAGCCore1, 0x2c);
@@ -2052,33 +2062,36 @@ static void dm_ctrl_initgain_byrssi_by_fwfalse_alarm(
 			write_nic_byte(dev, rOFDM0_XDAGCCore1, 0x20);
 		}

-		// 2.2 Higher PD_TH for OFDM.
+		/* 2.2 Higher PD_TH for OFDM. */
 		if (priv->CurrentChannelBW != HT_CHANNEL_WIDTH_20)
 		{
-			/* 2008/01/11 MH 40MHZ 90/92 register are not the same. */
-			// 2008/02/05 MH SD3-Jerry 92U/92E PD_TH are the same.
+			/*
+			 * 2008/01/11 MH 40MHZ 90/92 register are not the same.
+			 * 2008/02/05 MH SD3-Jerry 92U/92E PD_TH are the same.
+			 */
 			write_nic_byte(dev, (rOFDM0_XATxAFE+3), 0x20);
 			/*
 			else if (priv->card_8192 == HARDWARE_TYPE_RTL8190P)
 				write_nic_byte(dev, rOFDM0_RxDetector1, 0x42);
+			else if (pAdapter->HardwareType == HARDWARE_TYPE_RTL8192E)
+			else
+				PlatformEFIOWrite1Byte(pAdapter, rOFDM0_RxDetector1, 0x42);
 			*/
-			//else if (pAdapter->HardwareType == HARDWARE_TYPE_RTL8192E)
-
-			//else
-				//PlatformEFIOWrite1Byte(pAdapter, rOFDM0_RxDetector1, 0x42);
 		}
 		else
 			write_nic_byte(dev, rOFDM0_RxDetector1, 0x44);

-		// 2.3 Higher CS ratio for CCK.
+		/* 2.3 Higher CS ratio for CCK. */
 		write_nic_byte(dev, 0xa0a, 0xcd);

-		// 2.4 Lower EDCCA.
-		/* 2008/01/11 MH 90/92 series are the same. */
-		//PlatformEFIOWrite4Byte(pAdapter, rOFDM0_ECCAThreshold, 0x346);
+		/*
+		 * 2.4 Lower EDCCA.
+		 * 2008/01/11 MH 90/92 series are the same.
+		 */
+		/*PlatformEFIOWrite4Byte(pAdapter, rOFDM0_ECCAThreshold, 0x346);*/

-		// 2.5 DIG On.
-		rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x1);	// Only clear byte 1 and rewrite.
+		/* 2.5 DIG On. */
+		rtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x1);	/*  Only clear byte 1 and rewrite. */

 	}

@@ -2109,16 +2122,19 @@ static void dm_ctrl_initgain_byrssi_highpwr(
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	static u32 reset_cnt_highpwr;

-	// For smooth, we can not change high power DIG state in the range.
+	/*  For smooth, we can not change high power DIG state in the range. */
 	if ((priv->undecorated_smoothed_pwdb > dm_digtable.rssi_high_power_lowthresh) &&
 		(priv->undecorated_smoothed_pwdb < dm_digtable.rssi_high_power_highthresh))
 	{
 		return;
 	}

-	/* 3. When RSSI >75% or <70%, it is a high power issue. We have to judge if
-		  it is larger than a threshold and then execute the step below.  */
-	// 2008/02/05 MH SD3-Jerry Modify PD_TH for high power issue.
+	/*
+	 * 3. When RSSI >75% or <70%, it is a high power issue. We have to judge if
+	 *    it is larger than a threshold and then execute the step below.
+	 *
+	 * 2008/02/05 MH SD3-Jerry Modify PD_TH for high power issue.
+	 */
 	if (priv->undecorated_smoothed_pwdb >= dm_digtable.rssi_high_power_highthresh)
 	{
 		if (dm_digtable.dig_highpwr_state == DM_STA_DIG_ON &&
@@ -2127,7 +2143,7 @@ static void dm_ctrl_initgain_byrssi_highpwr(
 		else
 			dm_digtable.dig_highpwr_state = DM_STA_DIG_ON;

-		// 3.1 Higher PD_TH for OFDM for high power state.
+		/* 3.1 Higher PD_TH for OFDM for high power state. */
 		if (priv->CurrentChannelBW != HT_CHANNEL_WIDTH_20)
 		{
 			write_nic_byte(dev, (rOFDM0_XATxAFE+3), 0x10);
@@ -2151,7 +2167,7 @@ static void dm_ctrl_initgain_byrssi_highpwr(
 		if (priv->undecorated_smoothed_pwdb < dm_digtable.rssi_high_power_lowthresh &&
 			 priv->undecorated_smoothed_pwdb >= dm_digtable.rssi_high_thresh)
 		{
-			// 3.2 Recover PD_TH for OFDM for normal power region.
+			/*  3.2 Recover PD_TH for OFDM for normal power region. */
 			if (priv->CurrentChannelBW != HT_CHANNEL_WIDTH_20)
 			{
 				write_nic_byte(dev, (rOFDM0_XATxAFE+3), 0x20);
@@ -2196,7 +2212,7 @@ static void dm_initial_gain(
 			else
 				dm_digtable.cur_ig_value = dm_digtable.rssi_val+10-dm_digtable.backoff_val;
 		}
-		else		//current state is disconnected
+		else		/* current state is disconnected */
 		{
 			if(dm_digtable.cur_ig_value == 0)
 				dm_digtable.cur_ig_value = priv->DefaultInitialGain[0];
@@ -2204,14 +2220,14 @@ static void dm_initial_gain(
 				dm_digtable.cur_ig_value = dm_digtable.pre_ig_value;
 		}
 	}
-	else	// disconnected -> connected or connected -> disconnected
+	else	/*  disconnected -> connected or connected -> disconnected */
 	{
 		dm_digtable.cur_ig_value = priv->DefaultInitialGain[0];
 		dm_digtable.pre_ig_value = 0;
 	}
-	//DbgPrint("DM_DigTable.CurIGValue = 0x%x, DM_DigTable.PreIGValue = 0x%x\n", DM_DigTable.CurIGValue, DM_DigTable.PreIGValue);
+	/*DbgPrint("DM_DigTable.CurIGValue = 0x%x, DM_DigTable.PreIGValue = 0x%x\n", DM_DigTable.CurIGValue, DM_DigTable.PreIGValue);*/

-	// if silent reset happened, we should rewrite the values back
+	/* if silent reset happened, we should rewrite the values back */
 	if(priv->reset_count != reset_cnt)
 	{
 		force_write = 1;
@@ -2227,8 +2243,8 @@ static void dm_initial_gain(
 			|| !initialized || force_write)
 		{
 			initial_gain = (u8)dm_digtable.cur_ig_value;
-			//DbgPrint("Write initial gain = 0x%x\n", initial_gain);
-			// Set initial gain.
+			/*DbgPrint("Write initial gain = 0x%x\n", initial_gain);*/
+			/*  Set initial gain. */
 			write_nic_byte(dev, rOFDM0_XAAGCCore1, initial_gain);
 			write_nic_byte(dev, rOFDM0_XBAGCCore1, initial_gain);
 			write_nic_byte(dev, rOFDM0_XCAGCCore1, initial_gain);
@@ -2272,12 +2288,12 @@ static void dm_pd_th(
 			dm_digtable.curpd_thstate = DIG_PD_AT_LOW_POWER;
 		}
 	}
-	else	// disconnected -> connected or connected -> disconnected
+	else	/* disconnected -> connected or connected -> disconnected */
 	{
 		dm_digtable.curpd_thstate = DIG_PD_AT_LOW_POWER;
 	}

-	// if silent reset happened, we should rewrite the values back
+	/*  if silent reset happened, we should rewrite the values back */
 	if(priv->reset_count != reset_cnt)
 	{
 		force_write = 1;
@@ -2288,14 +2304,16 @@ static void dm_pd_th(
 		if((dm_digtable.prepd_thstate != dm_digtable.curpd_thstate) ||
 			(initialized<=3) || force_write)
 		{
-			//DbgPrint("Write PD_TH state = %d\n", DM_DigTable.CurPD_THState);
+			/*DbgPrint("Write PD_TH state = %d\n", DM_DigTable.CurPD_THState);*/
 			if(dm_digtable.curpd_thstate == DIG_PD_AT_LOW_POWER)
 			{
-				// Lower PD_TH for OFDM.
+				/*  Lower PD_TH for OFDM. */
 				if (priv->CurrentChannelBW != HT_CHANNEL_WIDTH_20)
 				{
-					/* 2008/01/11 MH 40MHZ 90/92 register are not the same. */
-					// 2008/02/05 MH SD3-Jerry 92U/92E PD_TH are the same.
+					/*
+					 * 2008/01/11 MH 40MHZ 90/92 register are not the same.
+					 * 2008/02/05 MH SD3-Jerry 92U/92E PD_TH are the same.
+					 */
 					write_nic_byte(dev, (rOFDM0_XATxAFE+3), 0x00);
 					/*else if (priv->card_8192 == HARDWARE_TYPE_RTL8190P)
 						write_nic_byte(dev, rOFDM0_RxDetector1, 0x40);
@@ -2306,11 +2324,13 @@ static void dm_pd_th(
 			}
 			else if(dm_digtable.curpd_thstate == DIG_PD_AT_NORMAL_POWER)
 			{
-				// Higher PD_TH for OFDM.
+				/* Higher PD_TH for OFDM. */
 				if (priv->CurrentChannelBW != HT_CHANNEL_WIDTH_20)
 				{
-					/* 2008/01/11 MH 40MHZ 90/92 register are not the same. */
-					// 2008/02/05 MH SD3-Jerry 92U/92E PD_TH are the same.
+					/*
+					 * 2008/01/11 MH 40MHZ 90/92 register are not the same.
+					 * 2008/02/05 MH SD3-Jerry 92U/92E PD_TH are the same.
+					 */
 					write_nic_byte(dev, (rOFDM0_XATxAFE+3), 0x20);
 					/*else if (priv->card_8192 == HARDWARE_TYPE_RTL8190P)
 						write_nic_byte(dev, rOFDM0_RxDetector1, 0x42);
@@ -2321,7 +2341,7 @@ static void dm_pd_th(
 			}
 			else if(dm_digtable.curpd_thstate == DIG_PD_AT_HIGH_POWER)
 			{
-				// Higher PD_TH for OFDM for high power state.
+				/* Higher PD_TH for OFDM for high power state. */
 				if (priv->CurrentChannelBW != HT_CHANNEL_WIDTH_20)
 				{
 					write_nic_byte(dev, (rOFDM0_XATxAFE+3), 0x10);
@@ -2369,12 +2389,12 @@ static	void dm_cs_ratio(
 			dm_digtable.curcs_ratio_state = DIG_CS_RATIO_LOWER;
 		}
 	}
-	else	// disconnected -> connected or connected -> disconnected
+	else	/* disconnected -> connected or connected -> disconnected */
 	{
 		dm_digtable.curcs_ratio_state = DIG_CS_RATIO_LOWER;
 	}

-	// if silent reset happened, we should rewrite the values back
+	/* if silent reset happened, we should rewrite the values back */
 	if(priv->reset_count != reset_cnt)
 	{
 		force_write = 1;
@@ -2386,15 +2406,15 @@ static	void dm_cs_ratio(
 		if((dm_digtable.precs_ratio_state != dm_digtable.curcs_ratio_state) ||
 			!initialized || force_write)
 		{
-			//DbgPrint("Write CS_ratio state = %d\n", DM_DigTable.CurCS_ratioState);
+			/*DbgPrint("Write CS_ratio state = %d\n", DM_DigTable.CurCS_ratioState);*/
 			if(dm_digtable.curcs_ratio_state == DIG_CS_RATIO_LOWER)
 			{
-				// Lower CS ratio for CCK.
+				/*  Lower CS ratio for CCK. */
 				write_nic_byte(dev, 0xa0a, 0x08);
 			}
 			else if(dm_digtable.curcs_ratio_state == DIG_CS_RATIO_HIGHER)
 			{
-				// Higher CS ratio for CCK.
+				/*  Higher CS ratio for CCK. */
 				write_nic_byte(dev, 0xa0a, 0xcd);
 			}
 			dm_digtable.precs_ratio_state = dm_digtable.curcs_ratio_state;
@@ -2411,41 +2431,41 @@ void dm_init_edca_turbo(struct net_device *dev)
 	priv->bcurrent_turbo_EDCA = false;
 	priv->ieee80211->bis_any_nonbepkts = false;
 	priv->bis_cur_rdlstate = false;
-}	// dm_init_edca_turbo
+}	/* dm_init_edca_turbo */

 static void dm_check_edca_turbo(
 	struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	PRT_HIGH_THROUGHPUT	pHTInfo = priv->ieee80211->pHTInfo;
-	//PSTA_QOS			pStaQos = pMgntInfo->pStaQos;
+	/*PSTA_QOS			pStaQos = pMgntInfo->pStaQos;*/

-	// Keep past Tx/Rx packet count for RT-to-RT EDCA turbo.
+	/* Keep past Tx/Rx packet count for RT-to-RT EDCA turbo. */
 	static unsigned long			lastTxOkCnt;
 	static unsigned long			lastRxOkCnt;
 	unsigned long				curTxOkCnt = 0;
 	unsigned long				curRxOkCnt = 0;

-	//
-	// Do not be Turbo if it's under WiFi config and Qos Enabled, because the EDCA parameters
-	// should follow the settings from QAP. By Bruce, 2007-12-07.
-	//
+	/*
+	 * Do not be Turbo if it's under WiFi config and Qos Enabled, because the EDCA parameters
+	 * should follow the settings from QAP. By Bruce, 2007-12-07.
+	 */
 	if(priv->ieee80211->state != IEEE80211_LINKED)
 		goto dm_CheckEdcaTurbo_EXIT;
-	// We do not turn on EDCA turbo mode for some AP that has IOT issue
+	/* We do not turn on EDCA turbo mode for some AP that has IOT issue */
 	if(priv->ieee80211->pHTInfo->IOTAction & HT_IOT_ACT_DISABLE_EDCA_TURBO)
 		goto dm_CheckEdcaTurbo_EXIT;

-//	printk("========>%s():bis_any_nonbepkts is %d\n",__func__,priv->bis_any_nonbepkts);
-	// Check the status for current condition.
+	/*printk("========>%s():bis_any_nonbepkts is %d\n",__func__,priv->bis_any_nonbepkts);*/
+	/* Check the status for current condition. */
 	if(!priv->ieee80211->bis_any_nonbepkts)
 	{
 		curTxOkCnt = priv->stats.txbytesunicast - lastTxOkCnt;
 		curRxOkCnt = priv->stats.rxbytesunicast - lastRxOkCnt;
-		// For RT-AP, we needs to turn it on when Rx>Tx
+		/* For RT-AP, we needs to turn it on when Rx>Tx */
 		if(curRxOkCnt > 4*curTxOkCnt)
 		{
-			//printk("%s():curRxOkCnt > 4*curTxOkCnt\n");
+			/*printk("%s():curRxOkCnt > 4*curTxOkCnt\n");*/
 			if(!priv->bis_cur_rdlstate || !priv->bcurrent_turbo_EDCA)
 			{
 				write_nic_dword(dev, EDCAPARA_BE, edca_setting_DL[pHTInfo->IOTPeer]);
@@ -2455,7 +2475,7 @@ static void dm_check_edca_turbo(
 		else
 		{

-			//printk("%s():curRxOkCnt < 4*curTxOkCnt\n");
+			/*printk("%s():curRxOkCnt < 4*curTxOkCnt\n");*/
 			if(priv->bis_cur_rdlstate || !priv->bcurrent_turbo_EDCA)
 			{
 				write_nic_dword(dev, EDCAPARA_BE, edca_setting_UL[pHTInfo->IOTPeer]);
@@ -2468,10 +2488,10 @@ static void dm_check_edca_turbo(
 	}
 	else
 	{
-		//
-		// Turn Off EDCA turbo here.
-		// Restore original EDCA according to the declaration of AP.
-		//
+		/*
+		 * Turn Off EDCA turbo here.
+		 * Restore original EDCA according to the declaration of AP.
+		 */
 		 if(priv->bcurrent_turbo_EDCA)
 		{

@@ -2481,30 +2501,32 @@ static void dm_check_edca_turbo(
 				struct ieee80211_qos_parameters *qos_parameters = &priv->ieee80211->current_network.qos_data.parameters;
 				u8 mode = priv->ieee80211->mode;

-			// For Each time updating EDCA parameter, reset EDCA turbo mode status.
+				/*  For Each time updating EDCA parameter, reset EDCA turbo mode status. */
 				dm_init_edca_turbo(dev);
 				u1bAIFS = qos_parameters->aifs[0] * ((mode&(IEEE_G|IEEE_N_24G)) ?9:20) + aSifsTime;
 				u4bAcParam = ((((u32)(qos_parameters->tx_op_limit[0]))<< AC_PARAM_TXOP_LIMIT_OFFSET)|
 					(((u32)(qos_parameters->cw_max[0]))<< AC_PARAM_ECW_MAX_OFFSET)|
 					(((u32)(qos_parameters->cw_min[0]))<< AC_PARAM_ECW_MIN_OFFSET)|
 					((u32)u1bAIFS << AC_PARAM_AIFS_OFFSET));
-			//write_nic_dword(dev, WDCAPARA_ADD[i], u4bAcParam);
+				/*write_nic_dword(dev, WDCAPARA_ADD[i], u4bAcParam);*/
 				write_nic_dword(dev, EDCAPARA_BE,  u4bAcParam);

-			// Check ACM bit.
-			// If it is set, immediately set ACM control bit to downgrading AC for passing WMM testplan. Annie, 2005-12-13.
+				/*
+				 * Check ACM bit.
+				 * If it is set, immediately set ACM control bit to downgrading AC for passing WMM testplan. Annie, 2005-12-13.
+				 */
 				{
-			// TODO:  Modified this part and try to set acm control in only 1 IO processing!!
+					/*  TODO:  Modified this part and try to set acm control in only 1 IO processing!! */

 					PACI_AIFSN	pAciAifsn = (PACI_AIFSN)&(qos_parameters->aifs[0]);
 					u8		AcmCtrl;
 					read_nic_byte(dev, AcmHwCtrl, &AcmCtrl);
 					if(pAciAifsn->f.ACM)
-					{ // ACM bit is 1.
+					{	/*  ACM bit is 1. */
 						AcmCtrl |= AcmHw_BeqEn;
 					}
 					else
-					{ // ACM bit is 0.
+					{	/* ACM bit is 0. */
 						AcmCtrl &= (~AcmHw_BeqEn);
 					}

@@ -2518,11 +2540,11 @@ static void dm_check_edca_turbo(


 dm_CheckEdcaTurbo_EXIT:
-	// Set variables for next time.
+	/* Set variables for next time. */
 	priv->ieee80211->bis_any_nonbepkts = false;
 	lastTxOkCnt = priv->stats.txbytesunicast;
 	lastRxOkCnt = priv->stats.rxbytesunicast;
-}	// dm_CheckEdcaTurbo
+}	/* dm_CheckEdcaTurbo */

 static void dm_init_ctstoself(struct net_device *dev)
 {
@@ -2556,12 +2578,12 @@ static void dm_ctstoself(struct net_device *dev)
 	{
 		curTxOkCnt = priv->stats.txbytesunicast - lastTxOkCnt;
 		curRxOkCnt = priv->stats.rxbytesunicast - lastRxOkCnt;
-		if(curRxOkCnt > 4*curTxOkCnt)	//downlink, disable CTS to self
+		if(curRxOkCnt > 4*curTxOkCnt)	/* downlink, disable CTS to self */
 		{
 			pHTInfo->IOTAction &= ~HT_IOT_ACT_FORCED_CTS2SELF;
-			//DbgPrint("dm_CTSToSelf() ==> CTS to self disabled -- downlink\n");
+			/*DbgPrint("dm_CTSToSelf() ==> CTS to self disabled -- downlink\n");*/
 		}
-		else	//uplink
+		else	/* uplink */
 		{
 			pHTInfo->IOTAction |= HT_IOT_ACT_FORCED_CTS2SELF;
 		}
@@ -2599,8 +2621,10 @@ static	void	dm_check_pbc_gpio(struct net_device *dev)

 	if (tmp1byte&BIT6 || tmp1byte&BIT0)
 	{
-		// Here we only set bPbcPressed to TRUE
-		// After trigger PBC, the variable will be set to FALSE
+		/*
+		 * Here we only set bPbcPressed to TRUE
+		 * After trigger PBC, the variable will be set to FALSE
+		 */
 		RT_TRACE(COMP_IO, "CheckPbcGPIO - PBC is pressed\n");
 		priv->bpbc_pressed = true;
 	}
@@ -2628,7 +2652,7 @@ void dm_rf_pathcheck_workitemcallback(struct work_struct *work)
 	struct delayed_work *dwork = container_of(work,struct delayed_work,work);
        struct r8192_priv *priv = container_of(dwork,struct r8192_priv,rfpath_check_wq);
        struct net_device *dev =priv->ieee80211->dev;
-	//bool bactually_set = false;
+       /*bool bactually_set = false;*/
 	u8 rfpath = 0, i;


@@ -2636,7 +2660,7 @@ void dm_rf_pathcheck_workitemcallback(struct work_struct *work)
 	   always be the same. We only read 0xc04 now. */
 	read_nic_byte(dev, 0xc04, &rfpath);

-	// Check Bit 0-3, it means if RF A-D is enabled.
+	/* Check Bit 0-3, it means if RF A-D is enabled. */
 	for (i = 0; i < RF90_PATH_MAX; i++)
 	{
 		if (rfpath & (0x01<<i))
@@ -2654,7 +2678,7 @@ static void dm_init_rxpath_selection(struct net_device *dev)
 {
 	u8 i;
 	struct r8192_priv *priv = ieee80211_priv(dev);
-	DM_RxPathSelTable.Enable = 1;	//default enabled
+	DM_RxPathSelTable.Enable = 1;	/* default enabled */
 	DM_RxPathSelTable.SS_TH_low = RxPathSelection_SS_TH_low;
 	DM_RxPathSelTable.diff_TH = RxPathSelection_diff_TH;
 	if(priv->CustomerID == RT_CID_819x_Netcore)
@@ -2676,8 +2700,8 @@ static void dm_rxpath_sel_byrssi(struct net_device *dev)
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u8				i, max_rssi_index=0, min_rssi_index=0, sec_rssi_index=0, rf_num=0;
 	u8				tmp_max_rssi=0, tmp_min_rssi=0, tmp_sec_rssi=0;
-	u8				cck_default_Rx=0x2;	//RF-C
-	u8				cck_optional_Rx=0x3;//RF-D
+	u8				cck_default_Rx=0x2;  /* RF-C */
+	u8				cck_optional_Rx=0x3; /* RF-D */
 	long				tmp_cck_max_pwdb=0, tmp_cck_min_pwdb=0, tmp_cck_sec_pwdb=0;
 	u8				cck_rx_ver2_max_index=0, cck_rx_ver2_min_index=0, cck_rx_ver2_sec_index=0;
 	u8				cur_rf_rssi;
@@ -2700,11 +2724,11 @@ static void dm_rxpath_sel_byrssi(struct net_device *dev)

 	if(priv->ieee80211->mode == WIRELESS_MODE_B)
 	{
-		DM_RxPathSelTable.cck_method = CCK_Rx_Version_2;	//pure B mode, fixed cck version2
-		//DbgPrint("Pure B mode, use cck rx version2 \n");
+		DM_RxPathSelTable.cck_method = CCK_Rx_Version_2;	/* pure B mode, fixed cck version2 */
+		/*DbgPrint("Pure B mode, use cck rx version2 \n");*/
 	}

-	//decide max/sec/min rssi index
+	/* decide max/sec/min rssi index */
 	for (i=0; i<RF90_PATH_MAX; i++)
 	{
 		if(!DM_RxPathSelTable.DbgMode)
@@ -2715,13 +2739,14 @@ static void dm_rxpath_sel_byrssi(struct net_device *dev)
 			rf_num++;
 			cur_rf_rssi = DM_RxPathSelTable.rf_rssi[i];

-			if(rf_num == 1)	// find first enabled rf path and the rssi values
-			{	//initialize, set all rssi index to the same one
+			if(rf_num == 1)
+			{	/* find first enabled rf path and the rssi values */
+				/* initialize, set all rssi index to the same one */
 				max_rssi_index = min_rssi_index = sec_rssi_index = i;
 				tmp_max_rssi = tmp_min_rssi = tmp_sec_rssi = cur_rf_rssi;
 			}
 			else if(rf_num == 2)
-			{	// we pick up the max index first, and let sec and min to be the same one
+			{	/* we pick up the max index first, and let sec and min to be the same one */
 				if(cur_rf_rssi >= tmp_max_rssi)
 				{
 					tmp_max_rssi = cur_rf_rssi;
@@ -2743,7 +2768,7 @@ static void dm_rxpath_sel_byrssi(struct net_device *dev)
 					max_rssi_index = i;
 				}
 				else if(cur_rf_rssi == tmp_max_rssi)
-				{	// let sec and min point to the different index
+				{	/* let sec and min point to the different index */
 					tmp_sec_rssi = cur_rf_rssi;
 					sec_rssi_index = i;
 				}
@@ -2755,29 +2780,29 @@ static void dm_rxpath_sel_byrssi(struct net_device *dev)
 				else if(cur_rf_rssi == tmp_sec_rssi)
 				{
 					if(tmp_sec_rssi == tmp_min_rssi)
-					{	// let sec and min point to the different index
+					{	/* let sec and min point to the different index */
 						tmp_sec_rssi = cur_rf_rssi;
 						sec_rssi_index = i;
 					}
 					else
 					{
-						// This case we don't need to set any index
+						/* This case we don't need to set any index */
 					}
 				}
 				else if((cur_rf_rssi < tmp_sec_rssi) && (cur_rf_rssi > tmp_min_rssi))
 				{
-					// This case we don't need to set any index
+					/* This case we don't need to set any index */
 				}
 				else if(cur_rf_rssi == tmp_min_rssi)
 				{
 					if(tmp_sec_rssi == tmp_min_rssi)
-					{	// let sec and min point to the different index
+					{	/* let sec and min point to the different index */
 						tmp_min_rssi = cur_rf_rssi;
 						min_rssi_index = i;
 					}
 					else
 					{
-						// This case we don't need to set any index
+						/* This case we don't need to set any index */
 					}
 				}
 				else if(cur_rf_rssi < tmp_min_rssi)
@@ -2790,7 +2815,7 @@ static void dm_rxpath_sel_byrssi(struct net_device *dev)
 	}

 	rf_num = 0;
-	// decide max/sec/min cck pwdb index
+	/* decide max/sec/min cck pwdb index */
 	if(DM_RxPathSelTable.cck_method == CCK_Rx_Version_2)
 	{
 		for (i=0; i<RF90_PATH_MAX; i++)
@@ -2800,13 +2825,13 @@ static void dm_rxpath_sel_byrssi(struct net_device *dev)
 				rf_num++;
 				cur_cck_pwdb =  DM_RxPathSelTable.cck_pwdb_sta[i];

-				if(rf_num == 1)	// find first enabled rf path and the rssi values
-				{	//initialize, set all rssi index to the same one
+				if(rf_num == 1)	/* find first enabled rf path and the rssi values */
+				{	/* initialize, set all rssi index to the same one */
 					cck_rx_ver2_max_index = cck_rx_ver2_min_index = cck_rx_ver2_sec_index = i;
 					tmp_cck_max_pwdb = tmp_cck_min_pwdb = tmp_cck_sec_pwdb = cur_cck_pwdb;
 				}
 				else if(rf_num == 2)
-				{	// we pick up the max index first, and let sec and min to be the same one
+				{	/* we pick up the max index first, and let sec and min to be the same one */
 					if(cur_cck_pwdb >= tmp_cck_max_pwdb)
 					{
 						tmp_cck_max_pwdb = cur_cck_pwdb;
@@ -2828,7 +2853,7 @@ static void dm_rxpath_sel_byrssi(struct net_device *dev)
 						cck_rx_ver2_max_index = i;
 					}
 					else if(cur_cck_pwdb == tmp_cck_max_pwdb)
-					{	// let sec and min point to the different index
+					{	/* let sec and min point to the different index */
 						tmp_cck_sec_pwdb = cur_cck_pwdb;
 						cck_rx_ver2_sec_index = i;
 					}
@@ -2840,29 +2865,29 @@ static void dm_rxpath_sel_byrssi(struct net_device *dev)
 					else if(cur_cck_pwdb == tmp_cck_sec_pwdb)
 					{
 						if(tmp_cck_sec_pwdb == tmp_cck_min_pwdb)
-						{	// let sec and min point to the different index
+						{	/* let sec and min point to the different index */
 							tmp_cck_sec_pwdb = cur_cck_pwdb;
 							cck_rx_ver2_sec_index = i;
 						}
 						else
 						{
-							// This case we don't need to set any index
+							/*  This case we don't need to set any index */
 						}
 					}
 					else if((cur_cck_pwdb < tmp_cck_sec_pwdb) && (cur_cck_pwdb > tmp_cck_min_pwdb))
 					{
-						// This case we don't need to set any index
+						/*  This case we don't need to set any index */
 					}
 					else if(cur_cck_pwdb == tmp_cck_min_pwdb)
 					{
 						if(tmp_cck_sec_pwdb == tmp_cck_min_pwdb)
-						{	// let sec and min point to the different index
+						{	/*  let sec and min point to the different index */
 							tmp_cck_min_pwdb = cur_cck_pwdb;
 							cck_rx_ver2_min_index = i;
 						}
 						else
 						{
-							// This case we don't need to set any index
+							/*  This case we don't need to set any index */
 						}
 					}
 					else if(cur_cck_pwdb < tmp_cck_min_pwdb)
@@ -2877,8 +2902,10 @@ static void dm_rxpath_sel_byrssi(struct net_device *dev)
 	}


-	// Set CCK Rx path
-	// reg0xA07[3:2]=cck default rx path, reg0xa07[1:0]=cck optional rx path.
+	/*
+	 * Set CCK Rx path
+	 * reg0xA07[3:2]=cck default rx path, reg0xa07[1:0]=cck optional rx path.
+	 */
 	update_cck_rx_path = 0;
 	if(DM_RxPathSelTable.cck_method == CCK_Rx_Version_2)
 	{
@@ -2892,11 +2919,11 @@ static void dm_rxpath_sel_byrssi(struct net_device *dev)
 	{
 		if((tmp_max_rssi - tmp_min_rssi) >= DM_RxPathSelTable.diff_TH)
 		{
-			//record the enabled rssi threshold
+			/* record the enabled rssi threshold */
 			DM_RxPathSelTable.rf_enable_rssi_th[min_rssi_index] = tmp_max_rssi+5;
-			//disable the BB Rx path, OFDM
-			rtl8192_setBBreg(dev, rOFDM0_TRxPathEnable, 0x1<<min_rssi_index, 0x0);	// 0xc04[3:0]
-			rtl8192_setBBreg(dev, rOFDM1_TRxPathEnable, 0x1<<min_rssi_index, 0x0);	// 0xd04[3:0]
+			/* disable the BB Rx path, OFDM */
+			rtl8192_setBBreg(dev, rOFDM0_TRxPathEnable, 0x1<<min_rssi_index, 0x0);	/* 0xc04[3:0] */
+			rtl8192_setBBreg(dev, rOFDM1_TRxPathEnable, 0x1<<min_rssi_index, 0x0);	/* 0xd04[3:0] */
 			disabled_rf_cnt++;
 		}
 		if(DM_RxPathSelTable.cck_method == CCK_Rx_Version_1)
@@ -2918,14 +2945,14 @@ static void dm_rxpath_sel_byrssi(struct net_device *dev)
 	{
 		for(i=0; i<4; i++)
 		{
-			if((DM_RxPathSelTable.disabledRF>>i) & 0x1)	//disabled rf
+			if((DM_RxPathSelTable.disabledRF>>i) & 0x1)	/* disabled rf */
 			{
 				if(tmp_max_rssi >= DM_RxPathSelTable.rf_enable_rssi_th[i])
 				{
-					//enable the BB Rx path
-					//DbgPrint("RF-%d is enabled. \n", 0x1<<i);
-					rtl8192_setBBreg(dev, rOFDM0_TRxPathEnable, 0x1<<i, 0x1);	// 0xc04[3:0]
-					rtl8192_setBBreg(dev, rOFDM1_TRxPathEnable, 0x1<<i, 0x1);	// 0xd04[3:0]
+					/* enable the BB Rx path */
+					/*DbgPrint("RF-%d is enabled. \n", 0x1<<i);*/
+					rtl8192_setBBreg(dev, rOFDM0_TRxPathEnable, 0x1<<i, 0x1);	/* 0xc04[3:0] */
+					rtl8192_setBBreg(dev, rOFDM1_TRxPathEnable, 0x1<<i, 0x1);	/* 0xd04[3:0] */
 					DM_RxPathSelTable.rf_enable_rssi_th[i] = 100;
 					disabled_rf_cnt--;
 				}
@@ -2969,7 +2996,7 @@ static void dm_init_fsync (struct net_device *dev)
 	priv->ieee80211->fsync_firstdiff_ratethreshold= 100;
 	priv->ieee80211->fsync_seconddiff_ratethreshold= 200;
 	priv->ieee80211->fsync_state = Default_Fsync;
-	priv->framesyncMonitor = 1;	// current default 0xc38 monitor on
+	priv->framesyncMonitor = 1;	/* current default 0xc38 monitor on */

 	init_timer(&priv->fsync_timer);
 	priv->fsync_timer.data = (unsigned long)dev;
@@ -2995,7 +3022,7 @@ void dm_fsync_timer_callback(unsigned long data)
 		priv->ieee80211->bfsync_enable &&
 		(priv->ieee80211->pHTInfo->IOTAction & HT_IOT_ACT_CDD_FSYNC))
 	{
-		 // Count rate 54, MCS [7], [12, 13, 14, 15]
+		/* Count rate 54, MCS [7], [12, 13, 14, 15] */
 		u32 rate_bitmap;
 		for(rate_index = 0; rate_index <= 27; rate_index++)
 		{
@@ -3012,13 +3039,13 @@ void dm_fsync_timer_callback(unsigned long data)
 		{

 			u32 DiffNum = priv->rateCountDiffRecord - rate_count_diff;
-			// Continue count
+			/* Continue count */
 			if(DiffNum >= priv->ieee80211->fsync_seconddiff_ratethreshold)
 				priv->ContinueDiffCount++;
 			else
 				priv->ContinueDiffCount = 0;

-			// Continue count over
+			/* Continue count over */
 			if(priv->ContinueDiffCount >=2)
 			{
 				bSwitchFromCountDiff = true;
@@ -3027,11 +3054,11 @@ void dm_fsync_timer_callback(unsigned long data)
 		}
 		else
 		{
-			// Stop the continued count
+			/* Stop the continued count */
 			priv->ContinueDiffCount = 0;
 		}

-		//If Count diff <= FsyncRateCountThreshold
+		/* If Count diff <= FsyncRateCountThreshold */
 		if(rate_count_diff <= priv->ieee80211->fsync_firstdiff_ratethreshold)
 		{
 			bSwitchFromCountDiff = true;
@@ -3040,7 +3067,7 @@ void dm_fsync_timer_callback(unsigned long data)
 		priv->rate_record = rate_count;
 		priv->rateCountDiffRecord = rate_count_diff;
 		RT_TRACE(COMP_HALDM, "rateRecord %d rateCount %d, rateCountdiff %d bSwitchFsync %d\n", priv->rate_record, rate_count, rate_count_diff , priv->bswitch_fsync);
-		// if we never receive those mcs rate and rssi > 30 % then switch fsyn
+		/* if we never receive those mcs rate and rssi > 30 % then switch fsyn */
 		if(priv->undecorated_smoothed_pwdb > priv->ieee80211->fsync_rssi_threshold && bSwitchFromCountDiff)
 		{
 			bDoubleTimeInterval = true;
@@ -3080,7 +3107,7 @@ void dm_fsync_timer_callback(unsigned long data)
 	}
 	else
 	{
-		// Let Register return to default value;
+		/* Let Register return to default value; */
 		if(priv->bswitch_fsync)
 		{
 			priv->bswitch_fsync  = false;
@@ -3108,7 +3135,7 @@ static void dm_EndSWFsync(struct net_device *dev)
 	RT_TRACE(COMP_HALDM, "%s\n", __func__);
 	del_timer_sync(&(priv->fsync_timer));

-	// Let Register return to default value;
+	/* Let Register return to default value; */
 	if(priv->bswitch_fsync)
 	{
 		priv->bswitch_fsync  = false;
@@ -3130,9 +3157,9 @@ static void dm_StartSWFsync(struct net_device *dev)
 	u32			rateBitmap;

 	RT_TRACE(COMP_HALDM, "%s\n", __func__);
-	// Initial rate record to zero, start to record.
+	/* Initial rate record to zero, start to record. */
 	priv->rate_record = 0;
-	// Initialize continue diff count to zero, start to record.
+	/* Initialize continue diff count to zero, start to record. */
 	priv->ContinueDiffCount = 0;
 	priv->rateCountDiffRecord = 0;
 	priv->bswitch_fsync  = false;
@@ -3176,7 +3203,7 @@ void dm_check_fsync(struct net_device *dev)
 #define	RegC38_NonFsync_Other_AP	1
 #define	RegC38_Fsync_AP_BCM		2
 	struct r8192_priv *priv = ieee80211_priv(dev);
-	//u32			framesyncC34;
+	/*u32			framesyncC34;*/
 	static u8		reg_c38_State=RegC38_Default;
 	static u32	reset_cnt;

@@ -3226,7 +3253,7 @@ void dm_check_fsync(struct net_device *dev)
 		if(priv->framesyncMonitor)
 		{
 			if(reg_c38_State != RegC38_Fsync_AP_BCM)
-			{	//For broadcom AP we write different default value
+			{	/* For broadcom AP we write different default value */
 				write_nic_byte(dev, rOFDM0_RxDetector3, 0x95);

 				reg_c38_State = RegC38_Fsync_AP_BCM;
@@ -3269,7 +3296,7 @@ void dm_check_fsync(struct net_device *dev)
 					{
 						write_nic_byte(dev, rOFDM0_RxDetector3, priv->framesync);
 						reg_c38_State = RegC38_Default;
-						//DbgPrint("Fsync is idle, rssi>=40, write 0xc38 = 0x%x \n", pHalData->framesync);
+						/*DbgPrint("Fsync is idle, rssi>=40, write 0xc38 = 0x%x \n", pHalData->framesync);*/
 					}
 				}
 			}
@@ -3279,7 +3306,7 @@ void dm_check_fsync(struct net_device *dev)
 				{
 					write_nic_byte(dev, rOFDM0_RxDetector3, priv->framesync);
 					reg_c38_State = RegC38_Default;
-					//DbgPrint("Fsync is idle, not connected, write 0xc38 = 0x%x \n", pHalData->framesync);
+					/*DbgPrint("Fsync is idle, not connected, write 0xc38 = 0x%x \n", pHalData->framesync);*/
 				}
 			}
 		}
@@ -3287,11 +3314,11 @@ void dm_check_fsync(struct net_device *dev)
 	if(priv->framesyncMonitor)
 	{
 		if(priv->reset_count != reset_cnt)
-		{	//After silent reset, the reg_c38_State will be returned to default value
+		{	/* After silent reset, the reg_c38_State will be returned to default value */
 			write_nic_byte(dev, rOFDM0_RxDetector3, priv->framesync);
 			reg_c38_State = RegC38_Default;
 			reset_cnt = priv->reset_count;
-			//DbgPrint("reg_c38_State = 0 for silent reset. \n");
+			/*DbgPrint("reg_c38_State = 0 for silent reset. \n");*/
 		}
 	}
 	else
@@ -3300,7 +3327,7 @@ void dm_check_fsync(struct net_device *dev)
 		{
 			write_nic_byte(dev, rOFDM0_RxDetector3, priv->framesync);
 			reg_c38_State = RegC38_Default;
-			//DbgPrint("framesync no monitor, write 0xc38 = 0x%x \n", pHalData->framesync);
+			/*DbgPrint("framesync no monitor, write 0xc38 = 0x%x \n", pHalData->framesync);*/
 		}
 	}
 }
@@ -3331,7 +3358,7 @@ void dm_shadow_init(struct net_device *dev)
 		for (offset = 0; offset < 256; offset++)
 		{
 			read_nic_byte(dev, offset+page*256, &dm_shadow[page][offset]);
-			//DbgPrint("P-%d/O-%02x=%02x\r\n", page, offset, DM_Shadow[page][offset]);
+			/*DbgPrint("P-%d/O-%02x=%02x\r\n", page, offset, DM_Shadow[page][offset]);*/
 		}

 	for (page = 8; page < 11; page++)
@@ -3366,8 +3393,8 @@ static void dm_init_dynamic_txpower(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);

-	//Initial TX Power Control for near/far range , add by amy 2008/05/15, porting from windows code.
-	priv->ieee80211->bdynamic_txpower_enable = true;    //Default to enable Tx Power Control
+	/* Initial TX Power Control for near/far range , add by amy 2008/05/15, porting from windows code. */
+	priv->ieee80211->bdynamic_txpower_enable = true;    /* Default to enable Tx Power Control */
 	priv->bLastDTPFlag_High = false;
 	priv->bLastDTPFlag_Low = false;
 	priv->bDynamicTxHighPower = false;
@@ -3385,7 +3412,7 @@ static void dm_dynamic_txpower(struct net_device *dev)
 		priv->bDynamicTxLowPower = false;
 		return;
 	}
-	//printk("priv->ieee80211->current_network.unknown_cap_exist is %d ,priv->ieee80211->current_network.broadcom_cap_exist is %d\n",priv->ieee80211->current_network.unknown_cap_exist,priv->ieee80211->current_network.broadcom_cap_exist);
+	/*printk("priv->ieee80211->current_network.unknown_cap_exist is %d ,priv->ieee80211->current_network.broadcom_cap_exist is %d\n",priv->ieee80211->current_network.unknown_cap_exist,priv->ieee80211->current_network.broadcom_cap_exist);*/
 	if((priv->ieee80211->current_network.atheros_cap_exist) && (priv->ieee80211->mode == IEEE_G)){
 		txhipower_threshhold = TX_POWER_ATHEROAP_THRESH_HIGH;
 		txlowpower_threshold = TX_POWER_ATHEROAP_THRESH_LOW;
@@ -3396,7 +3423,7 @@ static void dm_dynamic_txpower(struct net_device *dev)
 		txlowpower_threshold = TX_POWER_NEAR_FIELD_THRESH_LOW;
 	}

-//	printk("=======>%s(): txhipower_threshhold is %d,txlowpower_threshold is %d\n",__func__,txhipower_threshhold,txlowpower_threshold);
+	/*printk("=======>%s(): txhipower_threshhold is %d,txlowpower_threshold is %d\n",__func__,txhipower_threshhold,txlowpower_threshold);*/
 	RT_TRACE(COMP_TXAGC,"priv->undecorated_smoothed_pwdb = %ld \n" , priv->undecorated_smoothed_pwdb);

 	if(priv->ieee80211->state == IEEE80211_LINKED)
@@ -3408,12 +3435,12 @@ static void dm_dynamic_txpower(struct net_device *dev)
 		}
 		else
 		{
-			// high power state check
+			/* high power state check */
 			if(priv->undecorated_smoothed_pwdb < txlowpower_threshold && priv->bDynamicTxHighPower == true)
 			{
 				priv->bDynamicTxHighPower = false;
 			}
-			// low power state check
+			/* low power state check */
 			if(priv->undecorated_smoothed_pwdb < 35)
 			{
 				priv->bDynamicTxLowPower = true;
@@ -3426,7 +3453,7 @@ static void dm_dynamic_txpower(struct net_device *dev)
 	}
 	else
 	{
-		//pHalData->bTXPowerCtrlforNearFarRange = !pHalData->bTXPowerCtrlforNearFarRange;
+		/*pHalData->bTXPowerCtrlforNearFarRange = !pHalData->bTXPowerCtrlforNearFarRange;*/
 		priv->bDynamicTxHighPower = false;
 		priv->bDynamicTxLowPower = false;
 	}
@@ -3441,27 +3468,27 @@ static void dm_dynamic_txpower(struct net_device *dev)
 #endif

 		rtl8192_phy_setTxPower(dev,priv->ieee80211->current_network.channel);
-		//pHalData->bStartTxCtrlByTPCNFR = FALSE;    //Clear th flag of Set TX Power from Sitesurvey
+		/*pHalData->bStartTxCtrlByTPCNFR = FALSE;    Clear th flag of Set TX Power from Sitesurvey*/
 	}
 	priv->bLastDTPFlag_High = priv->bDynamicTxHighPower;
 	priv->bLastDTPFlag_Low = priv->bDynamicTxLowPower;

 }	/* dm_dynamic_txpower */

-//added by vivi, for read tx rate and retrycount
+/*added by vivi, for read tx rate and retrycount */
 static void dm_check_txrateandretrycount(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	struct ieee80211_device *ieee = priv->ieee80211;
-	//for 11n tx rate
-//	priv->stats.CurrentShowTxate = read_nic_byte(dev, Current_Tx_Rate_Reg);
+	/* for 11n tx rate */
+	/*priv->stats.CurrentShowTxate = read_nic_byte(dev, Current_Tx_Rate_Reg);*/
 	read_nic_byte(dev, Current_Tx_Rate_Reg, &ieee->softmac_stats.CurrentShowTxate);
-	//printk("=============>tx_rate_reg:%x\n", ieee->softmac_stats.CurrentShowTxate);
-	//for initial tx rate
-//	priv->stats.last_packet_rate = read_nic_byte(dev, Initial_Tx_Rate_Reg);
+	/*printk("=============>tx_rate_reg:%x\n", ieee->softmac_stats.CurrentShowTxate);*/
+	/* for initial tx rate */
+	/*priv->stats.last_packet_rate = read_nic_byte(dev, Initial_Tx_Rate_Reg);*/
 	read_nic_byte(dev, Initial_Tx_Rate_Reg, &ieee->softmac_stats.last_packet_rate);
-	//for tx tx retry count
-//	priv->stats.txretrycount = read_nic_dword(dev, Tx_Retry_Count_Reg);
+	/* for tx tx retry count */
+	/*priv->stats.txretrycount = read_nic_dword(dev, Tx_Retry_Count_Reg);*/
 	read_nic_dword(dev, Tx_Retry_Count_Reg, &ieee->softmac_stats.txretrycount);
 }

@@ -3469,9 +3496,11 @@ static void dm_send_rssi_tofw(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);

-	// If we test chariot, we should stop the TX command ?
-	// Because 92E will always silent reset when we send tx command. We use register
-	// 0x1e0(byte) to notify driver.
+	/*
+	 * If we test chariot, we should stop the TX command ?
+	 * Because 92E will always silent reset when we send tx command. We use register
+	 * 0x1e0(byte) to notify driver.
+	 */
 	write_nic_byte(dev, DRIVER_RSSI, (u8)priv->undecorated_smoothed_pwdb);
 	return;
 }
--
2.2.1
